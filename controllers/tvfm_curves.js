
// **********************************************************

'use strict';

// **********************************************************

var mathjs = require('mathjs');

// To avoid ReferenceError: function not defined, these anonymous functions need
// to be declared OUTSIDE the $(document).ready function 

//---- FM and TV Propagation Curves Data ---------------------------------------------------------------

// Distance values for F(50,50) curves 
   var D50 = [ 1.609344, 3.218688, 4.828032, 6.437376, 8.046720, 16.09344, 32.18688, 48.28032, 64.37376, 80.46720, 96.56064, 112.65408, 128.74752, 144.84096, 160.93440, 177.02784, 193.12128, 209.21472, 225.30816, 241.40160, 257.49504, 273.58848, 289.68192, 305.77536, 321.86880, 0.0 ];

// Distance values for F(50,10) curves
// Distance of D10(31) added to smooth out the graph and interpolation
// for the F(50,10) curve at the rarely used distance of (almost) 500 km  

   var D10 = [ 16.09344, 32.18688, 48.28032, 64.37376, 80.46720, 96.56064, 112.65408, 128.74752, 144.84096, 160.93440, 177.02784, 193.12128, 209.21472, 225.30816, 241.40160, 257.49504, 273.58848, 289.68192, 305.77536, 321.86880, 337.96224, 354.05568, 370.14912, 386.24256, 402.33600, 418.42944, 434.52288, 450.61632, 466.70976, 482.80320, 498.89644, 0.0 ];

// Height values H10, H50 in meters 
   var H50 = [ 30.48, 60.96, 121.92, 182.88, 243.84, 304.80, 381.00, 457.20, 533.40, 609.60, 914.40, 1219.20, 1524.00, 0.0 ];

   var H10 = [ 30.48, 60.96, 121.92, 182.88, 243.84, 304.80, 381.00, 457.20, 533.40, 609.60, 914.40, 1219.20, 1524.00, 0.0 ];


/************************************************************************
!  F(50,50) FIELD STRENGTH DATA FOR THE LOW VHF PROPAGATION CURVE.  (FM AND TV CHANNELS 2 THROUGH 6 )  --  (13 points * 25 curves = 325)                        *
!***********************************************************************/
// was [25][13] 

var F55LV = [ 92., 79.7 ,72.7 ,67.8 ,
	    64. ,52. ,39.4 ,31. ,25.3 ,20.3 ,16.2 ,12.8 ,9.8 ,6.9 ,4. ,1.5 ,
	    -1.1 ,-3.6 ,-5.8 ,-8.1 ,-10.6 ,-13. ,-15.1 ,-17.2 ,-19.2 ,98. ,
	    85.9 ,79. ,73.8 ,70. ,58. ,45.5 ,37. ,29.5 ,23.5 ,18.1 ,14.5 ,
	    11. ,8.2 ,5.5 ,2.9 ,.3 ,-2.2 ,-4.8 ,-7. ,-9.4 ,-11.7 ,-14. ,
	    -16.1 ,-18.3 ,100.6 ,91. ,84.8 ,80. ,76. ,64. ,51.5 ,43. ,35.5 ,
	    28.8 ,22. ,17.1 ,13.4 ,10.2 ,7.4 ,4.8 ,2.2 ,-.3 ,-3. ,-5.2 ,-7.6 ,
	    -10. ,-12.2 ,-14.6 ,-16.9 ,101.5 ,93.4 ,87.8 ,83.3 ,79.6 ,67.6 ,
	    55. ,46.7 ,39. ,32. ,25.3 ,19.8 ,15.2 ,11.8 ,8.9 ,6. ,3.7 ,1. ,
	    -1.4 ,-3.9 ,-6.1 ,-8.7 ,-11. ,-13.2 ,-15.6 ,101.9 ,94.6 ,89.4 ,
	    85.4 ,82. ,70. ,57.6 ,49. ,41.5 ,34.4 ,27.7 ,22. ,17. ,13.1 ,
	    10.1 ,7.2 ,4.8 ,2. ,-.3 ,-2.7 ,-5.1 ,-7.6 ,-10. ,-12.1 ,-14.6 ,
	    102. ,95. ,90.4 ,86.8 ,83.7 ,72. ,59.6 ,51. ,43.6 ,36.7 ,29.9 ,
	    23.9 ,18.8 ,14.7 ,11.5 ,8.4 ,5.7 ,3. ,.6 ,-1.8 ,-4.2 ,-6.6 ,-9. ,
	    -11.2 ,-13.6 ,102.1 ,95.6 ,91.2 ,87.7 ,85. ,73.9 ,61.7 ,53.2 ,
	    45.9 ,39.1 ,32. ,26. ,21. ,16.8 ,13.1 ,9.9 ,7. ,4.1 ,1.7 ,-.7 ,
	    -3.2 ,-5.6 ,-8. ,-10.2 ,-12.5 ,102.2 ,95.9 ,91.8 ,88.3 ,85.8 ,
	    75.4 ,63.3 ,55.1 ,47.9 ,41.5 ,34.4 ,28.3 ,23.2 ,18.8 ,14.9 ,11.1 ,
	    8. ,5.2 ,2.7 ,.2 ,-2.2 ,-4.6 ,-7. ,-9.2 ,-11.6 ,102.3 ,96. ,92. ,
	    88.9 ,86.3 ,76.7 ,64.9 ,57. ,50. ,43.5 ,36.7 ,30.7 ,25.2 ,20.4 ,
	    16. ,12.5 ,9.1 ,6.2 ,3.8 ,1.1 ,-1.3 ,-3.6 ,-6.1 ,-8.4 ,-10.6 ,
	    102.4 ,96.1 ,92.2 ,89.2 ,86.7 ,77.9 ,66.2 ,58.5 ,51.5 ,45. ,38.2 ,
	    32.4 ,27. ,22. ,17.3 ,13.7 ,10.1 ,7.1 ,4.6 ,2. ,-.4 ,-2.7 ,-5.1 ,
	    -7.6 ,-10. ,102.5 ,96.3 ,92.5 ,89.9 ,87.6 ,80.2 ,70. ,62.6 ,55.4 ,
	    48.9 ,42.5 ,36.9 ,31. ,25.7 ,21. ,17.1 ,13.6 ,10.3 ,7.8 ,5.1 ,
	    2.8 ,.5 ,-2.1 ,-4.5 ,-6.8 ,102.5 ,96.5 ,92.5 ,90.1 ,88. ,81.3 ,
	    72.4 ,65. ,57.8 ,51.2 ,44.9 ,39.1 ,33.2 ,28.1 ,23.5 ,19.8 ,16.1 ,
	    13. ,10.4 ,8. ,5.5 ,3.1 ,.6 ,-2. ,-4.1 ,102.5 ,96.5 ,92.5 ,90.2 ,
	    88.1 ,81.9 ,74.2 ,66.5 ,59.6 ,53. ,46.4 ,40.8 ,35. ,30. ,25.5 ,
	    21.8 ,18.3 ,15. ,12.4 ,10. ,7.7 ,5.1 ,2.8 ,.2 ,-2. ];


/***********************************************************************
!  F(50,10)  FIELD STRENGTH DATA  FOR THE LOW VHF PROPAGATION CURVE.  ( FM AND TV CHANNELS 2 THROUGH 6 ) -- (13 points * 31 curves = 403)              
!**********************************************************************/
// Includes a derived Interfering curve (31) to smooth out the graph and interpolation for the rarely used F(50,10) curve at 498.89644 km
// was [31][13] 

var F51LV = [ 52.2 ,41.4 ,36.4 ,33. ,
	    30. ,26.7 ,23.5 ,20.4 ,17.4 ,14.5 ,11.5 ,8.5 ,5.9 ,3. ,.6 ,-2. ,
	    -4.3 ,-6.6 ,-8.7 ,-10.5 ,-12.5 ,-14.6 ,-16.6 ,-18.6 ,-20.5 ,
	    -22.4 ,-24.3 ,-26.2 ,-28.1 ,-30. ,-31.9 ,58.4 ,47. ,40.9 ,36. ,
	    31.9 ,28. ,24.9 ,22. ,19. ,16.1 ,13.1 ,10.1 ,7.7 ,4.9 ,2. ,-.4 ,
	    -3. ,-5.1 ,-7.4 ,-9.4 ,-11.4 ,-13.4 ,-15.5 ,-17.4 ,-19.3 ,-21.2 ,
	    -23.2 ,-25. ,-27. ,-29. ,-31. ,64.3 ,53. ,45.9 ,39.9 ,35. ,30.5 ,
	    26.9 ,24. ,20.9 ,18.2 ,15.3 ,12.4 ,9.8 ,6.9 ,4.1 ,1.6 ,-1. ,-3.4 ,
	    -5.8 ,-8. ,-10.1 ,-12. ,-14.1 ,-16. ,-18. ,-19.9 ,-21.9 ,-23.7 ,
	    -25.6 ,-27.4 ,-29.2 ,68. ,56.5 ,49. ,43. ,37.7 ,32.8 ,28.8 ,25.6 ,
	    22.5 ,19.8 ,16.9 ,13.9 ,11. ,8.2 ,5.7 ,2.9 ,.3 ,-2.2 ,-4.6 ,-6.9 ,
	    -9. ,-11. ,-13. ,-15. ,-17. ,-18.9 ,-20.9 ,-22.5 ,-24.6 ,-26.3 ,
	    -28. ,70.5 ,59. ,51.7 ,45.4 ,40. ,34.9 ,30.4 ,27. ,23.9 ,21. ,
	    18.2 ,15.1 ,12.3 ,9.7 ,6.9 ,4.1 ,1.6 ,-1. ,-3.4 ,-5.7 ,-8. ,-10. ,
	    -12. ,-14. ,-16. ,-17.9 ,-19.9 ,-21.7 ,-23.6 ,-25.4 ,-27.2 ,72.3 ,
	    60.9 ,53.7 ,47.5 ,41.9 ,36.8 ,32. ,28.4 ,25. ,22. ,19.2 ,16.2 ,
	    13.4 ,10.7 ,8. ,5.3 ,2.7 ,0. ,-2.5 ,-4.9 ,-7. ,-9. ,-11.2 ,-13.2 ,
	    -15.1 ,-17. ,-19. ,-21. ,-23. ,-24.6 ,-26.2 ,74.2 ,63. ,56. ,50. ,
	    44.4 ,39.2 ,34.9 ,30.8 ,27. ,23.9 ,20.8 ,17.8 ,14.8 ,12. ,9.1 ,
	    6.7 ,3.9 ,1.1 ,-1.4 ,-3.9 ,-6. ,-8. ,-10.2 ,-12.2 ,-14.2 ,-16.2 ,
	    -18.1 ,-20. ,-22. ,-23.7 ,-25.4 ,75.9 ,64.8 ,57.9 ,52. ,46.7 ,
	    41.6 ,37.1 ,33. ,29. ,25.5 ,22. ,19. ,16. ,13.2 ,10.3 ,7.9 ,5. ,
	    2.2 ,-.2 ,-2.8 ,-5. ,-7. ,-9.2 ,-11.3 ,-13.3 ,-15.3 ,-17.2 ,
	    -19.2 ,-21.1 ,-22.8 ,-24.5 ,77. ,66.2 ,59.6 ,54. ,48.5 ,43.5 ,
	    39.2 ,35. ,30.8 ,26.9 ,23.2 ,20. ,17.1 ,14.2 ,11.6 ,9. ,6. ,3.3 ,
	    .9 ,-1.8 ,-4. ,-6.2 ,-8.2 ,-10.5 ,-12.5 ,-14.6 ,-16.3 ,-18.4 ,
	    -20.2 ,-22. ,-23.8 ,78.2 ,67.6 ,60.9 ,55.2 ,50. ,45. ,40.7 ,36.2 ,
	    32. ,28. ,24.1 ,21. ,18. ,15.3 ,12.5 ,10. ,7. ,4.4 ,1.8 ,-.8 ,
	    -3. ,-5.3 ,-7.4 ,-9.8 ,-11.8 ,-14. ,-15.8 ,-17.8 ,-19.6 ,-21.3 ,
	    -23. ,80.8 ,71.2 ,64.5 ,58.9 ,53.9 ,49. ,44.2 ,39.8 ,35.4 ,31.3 ,
	    27.6 ,24.4 ,21.6 ,18.9 ,16. ,13.6 ,10.7 ,8. ,5.2 ,2.8 ,.3 ,-2. ,
	    -4.5 ,-7. ,-9. ,-11.1 ,-13.2 ,-15. ,-17. ,-19. ,-21. ,81.8 ,73.8 ,
	    67. ,61.4 ,56.3 ,51.7 ,46.9 ,42. ,37.8 ,33.8 ,30. ,27. ,24.1 ,
	    21.5 ,18.8 ,16.1 ,13.6 ,10.9 ,8.1 ,5.3 ,3. ,.4 ,-1.9 ,-4.3 ,-6.7 ,
	    -9. ,-11. ,-12.9 ,-14.9 ,-16.9 ,-18.9 ,82.2 ,75.5 ,69. ,63.3 ,
	    58.4 ,53.5 ,48.8 ,44. ,39.7 ,35.7 ,32.1 ,29.1 ,26.1 ,23.5 ,20.9 ,
	    18. ,15.7 ,13. ,10.2 ,7.5 ,5. ,2.6 ,0. ,-2.4 ,-4.6 ,-6.9 ,-9. ,
	    -11. ,-13. ,-15. ,-17. ];


/***********************************************************************
!  F(50,50) FIELD STRENGTH DATA FOR THE HIGH VHF PROPAGATION CURVE  ( TV CHANNELS 7 THROUGH 13 ) -- (13 points * 25 rows = 325) 
!*********************************************************************/
// was [25][13] 
 

var F55HV = [ 94.6 ,82.8 ,75.7 ,
	    70.7 ,66.8 ,55. ,42.5 ,34. ,26.3 ,20.7 ,16.3 ,12.9 ,9.9 ,7. ,4.3 ,
	    1.5 ,-1. ,-3.5 ,-5.7 ,-8. ,-10.4 ,-12.8 ,-15. ,-17.2 ,-19.1 ,
	    100.7 ,88.9 ,81.8 ,76.9 ,73. ,61. ,48.6 ,40. ,32. ,24.1 ,18.5 ,
	    14.4 ,11.2 ,8.3 ,5.5 ,2.9 ,.5 ,-2. ,-4.3 ,-6.9 ,-9.2 ,-11.5 ,
	    -13.8 ,-16. ,-18.2 ,101.6 ,92.3 ,86.6 ,82.2 ,78.8 ,67.2 ,54.7 ,
	    46.1 ,38.1 ,30.1 ,23. ,17. ,13.5 ,10.5 ,7.5 ,4.8 ,2.3 ,-.3 ,-2.7 ,
	    -5. ,-7.3 ,-9.8 ,-12. ,-14.4 ,-16.8 ,101.8 ,93.9 ,88.7 ,84.8 ,
	    81.6 ,70.8 ,58.1 ,49.8 ,41.7 ,33.8 ,26.2 ,20. ,15.2 ,12. ,9. ,
	    6.2 ,3.7 ,1. ,-1.2 ,-3.7 ,-6. ,-8.4 ,-10.7 ,-13. ,-15.5 ,101.9 ,
	    94.6 ,89.8 ,86.2 ,83.2 ,73.2 ,60.7 ,52.1 ,44. ,36.1 ,28.8 ,22.1 ,
	    17. ,13.7 ,10.4 ,7.5 ,4.8 ,2.2 ,-.1 ,-2.5 ,-4.9 ,-7.3 ,-9.7 ,
	    -12. ,-14.4 ,102. ,95. ,90.5 ,87. ,84.5 ,75. ,62.5 ,54.2 ,46. ,
	    38. ,30.6 ,24. ,18.9 ,15. ,11.5 ,8.6 ,5.8 ,3.2 ,.9 ,-1.5 ,-4. ,
	    -6.3 ,-8.7 ,-11. ,-13.4 ,102.3 ,95.4 ,91.3 ,88. ,85.7 ,77. ,65. ,
	    56.7 ,48.8 ,40.9 ,33.5 ,26.8 ,21.2 ,17. ,13.1 ,10. ,7. ,4.4 ,2. ,
	    -.5 ,-3. ,-5.3 ,-7.6 ,-10. ,-12.3 ,102.3 ,95.7 ,91.8 ,88.7 ,86.3 ,
	    78.1 ,67.6 ,59. ,51. ,43.5 ,36.3 ,29.6 ,23.9 ,19. ,14.9 ,11.2 ,
	    8.2 ,5.5 ,3. ,.6 ,-2. ,-4.3 ,-6.6 ,-9. ,-11.3 ,102.3 ,95.9 ,92. ,
	    89.1 ,87. ,79.1 ,69.5 ,61. ,53.3 ,46. ,39. ,32. ,26. ,21. ,16.2 ,
	    12.7 ,9.5 ,6.5 ,4. ,1.5 ,-1. ,-3.5 ,-5.8 ,-8.2 ,-10.5 ,102.4 ,
	    96. ,92.1 ,89.5 ,87.3 ,80. ,71. ,62.8 ,55. ,47.9 ,41. ,34. ,28. ,
	    22.6 ,17.5 ,13.6 ,10.5 ,7.4 ,4.9 ,2.2 ,-.2 ,-2.6 ,-5. ,-7.3 ,
	    -9.8 ,102.4 ,96.2 ,92.6 ,90. ,88. ,81.1 ,73.9 ,66.3 ,58.7 ,52. ,
	    45. ,38.2 ,32. ,26.3 ,21.1 ,17. ,14. ,10.7 ,8. ,5.6 ,3. ,.6 ,
	    -1.8 ,-4.2 ,-6.6 ,102.4 ,96.2 ,92.6 ,90. ,88. ,81.8 ,74.8 ,67.4 ,
	    60.3 ,53.8 ,47. ,40.6 ,34.4 ,28.8 ,23.8 ,19.8 ,16.6 ,13.1 ,10.4 ,
	    8.2 ,5.5 ,3.1 ,.9 ,-1.8 ,-4. ,102.5 ,96.5 ,92.7 ,90.1 ,88. ,82. ,
	    75. ,68. ,61.1 ,54.6 ,48.1 ,42. ,36.1 ,30.6 ,25.5 ,21.8 ,18.5 ,
	    15.1 ,12.3 ,10.1 ,7.5 ,5.1 ,2.9 ,.3 ,-1.9 ];



/***********************************************************************
!   F(50,10) FIELD STRENGTH DATA FOR THE HIGH VHF PROPAGATION CURVE  ( TV CHANNELS 7 THROUGH 13 ) -- (13 points * 31 curves = 403)                     
!***********************************************************************/
// Includes a derived Interfering curve (31) to smooth out the graph and interpolation for the rarely used F(50,10) curve at 498.89644 km
// was [31][13]  

var F51HV  = [ 55.4 ,44.4 ,39.2 ,34. ,
	    29.9 ,26.6 ,23.5 ,20.3 ,17.4 ,14.3 ,11.3 ,8.6 ,5.8 ,2.9 ,.3 ,
	    -2.1 ,-4.4 ,-6.7 ,-8.9 ,-10.8 ,-12.9 ,-14.8 ,-16.9 ,-18.8 ,-20.7 ,
	    -22.7 ,-24.6 ,-26.4 ,-28.2 ,-30.1 ,-32. ,61.6 ,50. ,43.5 ,38. ,
	    32.5 ,28.2 ,25. ,22. ,19. ,16. ,13. ,10. ,7.2 ,4.7 ,1.9 ,-.7 ,
	    -3.2 ,-5.4 ,-7.8 ,-9.8 ,-11.8 ,-13.8 ,-15.8 ,-17.7 ,-19.7 ,-21.4 ,
	    -23.3 ,-25.2 ,-27.1 ,-29. ,-30.9 ,67.7 ,55.8 ,48.6 ,42.7 ,35.9 ,
	    31. ,27. ,24. ,21. ,18.1 ,15.1 ,12.2 ,9.4 ,6.8 ,3.8 ,1.2 ,-1.4 ,
	    -3.8 ,-6.1 ,-8.2 ,-10.3 ,-12.3 ,-14.3 ,-16.3 ,-18.3 ,-20.1 ,-22. ,
	    -24. ,-25.9 ,-27.7 ,-29.5 ,71. ,59.1 ,52. ,45.6 ,38.8 ,33.4 ,
	    28.9 ,25.5 ,22.4 ,19.6 ,16.7 ,13.7 ,10.8 ,8.1 ,5.2 ,2.7 ,0. ,
	    -2.3 ,-4.8 ,-7. ,-9. ,-11.1 ,-13.1 ,-15.1 ,-17. ,-19. ,-20.9 ,
	    -22.9 ,-24.8 ,-26.5 ,-28.2 ,73.5 ,61.7 ,54.6 ,48. ,41. ,35.4 ,
	    30.7 ,27. ,23.8 ,20.8 ,18. ,15. ,12. ,9.5 ,6.5 ,3.9 ,1.2 ,-1.2 ,
	    -3.8 ,-6. ,-8.2 ,-10.2 ,-12.2 ,-14.2 ,-16.2 ,-18. ,-20. ,-21.9 ,
	    -23.9 ,-25.5 ,-27.1 ,75.3 ,63.7 ,56.5 ,50. ,43. ,37.4 ,32.3 ,
	    28.3 ,25. ,22. ,19.1 ,16.3 ,13.3 ,10.6 ,7.8 ,5. ,2.4 ,0. ,-2.6 ,
	    -5. ,-7.1 ,-9.3 ,-11.2 ,-13.3 ,-15.3 ,-17.2 ,-19.1 ,-21. ,-23. ,
	    -24.9 ,-26.7 ,77.1 ,66.5 ,59. ,52.5 ,45.8 ,40. ,35. ,30.4 ,26.9 ,
	    23.5 ,20.5 ,17.6 ,14.7 ,12. ,9. ,6.4 ,3.7 ,1. ,-1.4 ,-4. ,-6. ,
	    -8.2 ,-10.2 ,-12.3 ,-14.3 ,-16.2 ,-18.2 ,-20. ,-22. ,-23.9 ,
	    -25.8 ,78.6 ,68.9 ,61.5 ,54.9 ,48.2 ,43. ,37.4 ,32.9 ,28.8 ,25. ,
	    22. ,18.8 ,15.9 ,13. ,10.3 ,7.5 ,4.9 ,2.1 ,-.3 ,-3. ,-5.1 ,-7.4 ,
	    -9.4 ,-11.4 ,-13.5 ,-15.4 ,-17.4 ,-19.2 ,-21.1 ,-23. ,-24.9 ,
	    79.6 ,70.8 ,63.6 ,56.9 ,50.8 ,45.4 ,40. ,35. ,30.4 ,26.4 ,23. ,
	    19.9 ,17. ,14.1 ,11.5 ,8.8 ,6. ,3.3 ,.8 ,-2. ,-4.2 ,-6.5 ,-8.6 ,
	    -10.6 ,-12.8 ,-14.8 ,-16.8 ,-18.5 ,-20.3 ,-22.1 ,-23.9 ,80.4 ,
	    72. ,65.2 ,58.8 ,53. ,47.6 ,42. ,36.8 ,32. ,27.7 ,24. ,20.7 ,18. ,
	    15.2 ,12.5 ,9.8 ,7. ,4.3 ,1.7 ,-1. ,-3.3 ,-5.6 ,-7.8 ,-9.8 ,-12. ,
	    -14. ,-16. ,-18. ,-19.6 ,-21.5 ,-23.4 ,82. ,75. ,68.6 ,62.5 ,57. ,
	    52. ,46.8 ,41.5 ,35.8 ,31. ,27.6 ,24. ,21.4 ,18.8 ,16. ,13.1 ,
	    10.6 ,7.9 ,5. ,2.5 ,0. ,-2.4 ,-4.7 ,-6.9 ,-9. ,-11.1 ,-13.1 ,
	    -15.1 ,-17. ,-19. ,-21. ,82.4 ,75.9 ,69.8 ,64. ,58.9 ,53.8 ,48.9 ,
	    43.7 ,38.2 ,33.6 ,30. ,26.8 ,24. ,21.2 ,18.7 ,15.9 ,13.2 ,10.6 ,
	    8. ,5.2 ,2.8 ,.2 ,-2. ,-4.3 ,-6.5 ,-9. ,-11. ,-13. ,-15. ,-16.8 ,
	    -18.6 ,82.5 ,76.2 ,70.2 ,64.9 ,59.8 ,54.8 ,50. ,45. ,40.1 ,35.5 ,
	    32. ,28.9 ,26. ,23.4 ,20.7 ,18. ,15.4 ,12.8 ,10. ,7.3 ,4.9 ,2.2 ,
	    -.1 ,-2.4 ,-4.7 ,-7. ,-9. ,-11. ,-13. ,-15. ,-17. ];

/***********************************************************************
!   F(50,50) FIELD STRENGTH DATA FOR THE UHF PROPAGATION CURVE ( TV CHANNELS 14 THROUGH 83 ) -- (13 points * 25 curves = 325)                          
!***********************************************************************/
// was [25][13]

var F55U =  [ 92. ,80. ,72.9 ,67.9 ,
	    63.8 ,51.9 ,39. ,27.5 ,17.8 ,13. ,10.1 ,7. ,4.2 ,1.6 ,-1. ,-3.2 ,
	    -5. ,-7.2 ,-9.1 ,-11. ,-13.1 ,-15.1 ,-17.2 ,-19.3 ,-21.4 ,97.9 ,
	    86. ,79. ,74. ,70. ,58. ,45.2 ,33.5 ,22.7 ,16. ,11.7 ,8.5 ,5.5 ,
	    2.8 ,.2 ,-2. ,-4.2 ,-6.3 ,-8.4 ,-10.3 ,-12.3 ,-14.2 ,-16.2 ,
	    -18.3 ,-20.1 ,100.7 ,91. ,84.7 ,80. ,76. ,64. ,51.2 ,39.6 ,28.2 ,
	    19.6 ,14.4 ,10.8 ,7.7 ,4.7 ,1.9 ,-.4 ,-2.7 ,-4.9 ,-7. ,-8.9 ,
	    -10.9 ,-12.8 ,-14.8 ,-16.8 ,-18.7 ,101.5 ,93. ,87.4 ,83.3 ,79.5 ,
	    67.6 ,54.6 ,43. ,31.5 ,22.3 ,16.8 ,12.5 ,9.3 ,6. ,3.2 ,.7 ,-1.5 ,
	    -3.8 ,-5.9 ,-7.9 ,-9.9 ,-11.7 ,-13.8 ,-15.8 ,-17.7 ,101.9 ,94.1 ,
	    89. ,85.1 ,81.5 ,70. ,57.2 ,45.7 ,34.5 ,25.1 ,19.1 ,14.2 ,10.8 ,
	    7.5 ,4.6 ,1.9 ,-.4 ,-2.9 ,-5. ,-7. ,-9. ,-10.8 ,-12.8 ,-14.8 ,
	    -16.8 ,102. ,94.8 ,90. ,86.3 ,82.9 ,72. ,59.1 ,48. ,37.3 ,28.3 ,
	    21.7 ,16.3 ,12.4 ,8.9 ,5.7 ,3. ,.5 ,-2. ,-4.2 ,-6.1 ,-8. ,-10. ,
	    -11.9 ,-13.9 ,-15.9 ,102.1 ,95.2 ,90.8 ,87.3 ,84.1 ,73.8 ,61. ,
	    50.5 ,40.3 ,31.8 ,24.7 ,19. ,14.5 ,10.6 ,7.1 ,4.3 ,1.7 ,-.9 ,
	    -3.2 ,-5.2 ,-7.1 ,-9. ,-11. ,-13. ,-15. ,102.2 ,95.6 ,91.3 ,88. ,
	    85. ,75.3 ,62.6 ,52.3 ,42.7 ,34.1 ,27. ,21.3 ,16.3 ,12. ,8.5 ,
	    5.6 ,2.8 ,0. ,-2.3 ,-4.3 ,-6.2 ,-8.2 ,-10.2 ,-12.2 ,-14.1 ,102.3 ,
	    95.9 ,91.8 ,88.6 ,85.8 ,76.5 ,64. ,53.9 ,44.3 ,36. ,29.3 ,23.4 ,
	    18. ,13.6 ,9.7 ,6.7 ,3.8 ,1. ,-1.6 ,-3.6 ,-5.5 ,-7.5 ,-9.5 ,
	    -11.4 ,-13.2 ,102.4 ,96. ,92. ,88.9 ,86.2 ,77.2 ,65. ,55. ,45.7 ,
	    37.6 ,31. ,25. ,19.8 ,15. ,10.8 ,7.7 ,4.8 ,1.9 ,-.9 ,-3. ,-4.8 ,
	    -6.8 ,-8.9 ,-10.8 ,-12.5 ,102.5 ,96.3 ,92.5 ,89.6 ,87.3 ,79.6 ,
	    68.2 ,58.4 ,49.4 ,41.7 ,35.4 ,29.8 ,24.5 ,19.8 ,15. ,11.5 ,8.2 ,
	    5. ,2. ,-.2 ,-2.2 ,-4.3 ,-6.3 ,-8.3 ,-10. ,102.5 ,96.5 ,92.8 ,
	    90. ,87.9 ,80.5 ,70. ,60.8 ,52.1 ,44.8 ,38.6 ,33. ,28. ,23.4 ,
	    18.8 ,14.8 ,11.1 ,7.8 ,4.6 ,1.9 ,-.1 ,-2.2 ,-4.2 ,-6.1 ,-8. ,
	    102.5 ,96.5 ,93. ,90.3 ,88.1 ,81. ,71.1 ,62.5 ,54. ,46.7 ,41. ,
	    35.7 ,30.8 ,26. ,21.8 ,17.5 ,13.7 ,10. ,6.7 ,3.7 ,1.7 ,-.4 ,-2.3 ,
	    -4.4 ,-6.3 ];

/***********************************************************************
!   F(50,10) FIELD STRENGTH DATA FOR THE UHF PROPAGATION CURVE ( TV CHANNELS 14 THROUGH 83 )  - (13 points * 31 curves = 403)                          
!***********************************************************************/
// Includes a derived Interfering curve (31) to smooth out the graph and interpolation for the rarely used F(50,10) curve at 498.89644 km
// was [31][13]  

var F51U =  [ 52.2 ,41.6 ,35. ,30.3 ,
	    27. ,23.8 ,20.8 ,17.8 ,14.8 ,12. ,9.2 ,6.6 ,4. ,1.2 ,-1.3 ,-3.8 ,
	    -6. ,-8.4 ,-10.3 ,-12.5 ,-14.5 ,-16.5 ,-18.5 ,-20.5 ,-22.4 ,
	    -24.2 ,-26. ,-27.8 ,-29.5 ,-31. ,-32.5 ,58.3 ,46.7 ,38. ,32.1 ,
	    28.3 ,25.2 ,22.2 ,19.3 ,16.5 ,13.4 ,10.7 ,8. ,5.1 ,2.5 ,-.2 ,
	    -2.4 ,-4.9 ,-7.2 ,-9.3 ,-11.3 ,-13.5 ,-15.5 ,-17.4 ,-19.3 ,-21.3 ,
	    -23.2 ,-25. ,-27. ,-28.5 ,-30.1 ,-31.6 ,64.7 ,52.4 ,43. ,35.3 ,
	    30.8 ,27.6 ,24.5 ,21.3 ,18.5 ,15.6 ,12.7 ,9.9 ,7.1 ,4.4 ,1.8 ,
	    -.8 ,-3.1 ,-5.5 ,-7.7 ,-9.8 ,-12. ,-14. ,-15.9 ,-17.8 ,-19.8 ,
	    -21.6 ,-23.4 ,-25.5 ,-27.1 ,-28.9 ,-30.7 ,68. ,56. ,46.3 ,37.6 ,
	    32.6 ,29.1 ,26. ,23. ,20. ,17.1 ,14. ,11.2 ,8.8 ,6. ,3.2 ,.8 ,
	    -1.7 ,-4.1 ,-6.2 ,-8.4 ,-10.4 ,-12.7 ,-14.6 ,-16.5 ,-18.6 ,-20.4 ,
	    -22.2 ,-24.2 ,-26. ,-27.9 ,-29.8 ,70.5 ,58.5 ,48.8 ,40. ,34.7 ,
	    30.4 ,27.2 ,24.2 ,21.2 ,18.3 ,15.2 ,12.6 ,10. ,7.3 ,4.6 ,1.9 ,
	    -.5 ,-3. ,-5.2 ,-7.4 ,-9.6 ,-11.7 ,-13.8 ,-15.6 ,-17.7 ,-19.6 ,
	    -21.3 ,-23.3 ,-25. ,-27. ,-29. ,72.3 ,60.3 ,50.8 ,42.4 ,36.7 ,
	    32. ,28.4 ,25.4 ,22.4 ,19.7 ,16.5 ,13.8 ,11. ,8.3 ,5.7 ,3. ,.6 ,
	    -2. ,-4.3 ,-6.6 ,-8.8 ,-10.8 ,-13. ,-14.9 ,-17. ,-18.9 ,-20.8 ,
	    -22.7 ,-24.4 ,-26.3 ,-28.2 ,74.1 ,62.3 ,52.9 ,45.1 ,39. ,34.5 ,
	    30.4 ,27. ,23.9 ,21. ,18. ,15.3 ,12.5 ,9.7 ,7. ,4.4 ,1.8 ,-.7 ,
	    -3.2 ,-5.4 ,-7.7 ,-9.8 ,-12. ,-14. ,-16. ,-17.9 ,-19.9 ,-21.8 ,
	    -23.7 ,-25.6 ,-27.5 ,75.4 ,63.9 ,54.9 ,47.1 ,40.8 ,36.4 ,32.2 ,
	    28.8 ,25.2 ,22.1 ,19.3 ,16.4 ,13.8 ,10.9 ,8.1 ,5.6 ,2.9 ,.3 ,
	    -2.2 ,-4.5 ,-6.7 ,-8.9 ,-11. ,-13. ,-15. ,-17. ,-19.1 ,-21. ,
	    -22.8 ,-24.8 ,-26.8 ,76.4 ,65.2 ,56.3 ,48.7 ,42.4 ,37.9 ,33.9 ,
	    30.2 ,26.6 ,23.4 ,20.3 ,17.3 ,14.8 ,11.9 ,9.1 ,6.7 ,3.9 ,1.3 ,
	    -1.2 ,-3.6 ,-5.8 ,-7.9 ,-10. ,-12.2 ,-14.2 ,-16.2 ,-18.2 ,-20.2 ,
	    -22. ,-24. ,-26. ,77.4 ,66.2 ,57.6 ,50. ,43.7 ,39. ,35.1 ,31.7 ,
	    27.8 ,24.6 ,21.3 ,18.3 ,15.7 ,12.8 ,10. ,7.6 ,4.8 ,2.1 ,-.4 ,
	    -2.8 ,-5. ,-7.1 ,-9.2 ,-11.3 ,-13.4 ,-15.4 ,-17.5 ,-19.4 ,-21.3 ,
	    -23.2 ,-25.1 ,79.5 ,69.3 ,60.9 ,53.6 ,47.7 ,43.1 ,39.2 ,35.8 ,
	    32. ,28.3 ,24.9 ,21.7 ,18.8 ,15.9 ,13.1 ,10.6 ,7.9 ,5.1 ,2.2 ,0. ,
	    -2.2 ,-4.3 ,-6.6 ,-8.9 ,-11. ,-13. ,-15. ,-17. ,-19. ,-21. ,
	    -22.9 ,80.7 ,71.2 ,63. ,56.1 ,50.2 ,46. ,42.1 ,38.7 ,35. ,31.3 ,
	    27.8 ,24.3 ,21.2 ,18.2 ,15.5 ,12.8 ,10. ,7.3 ,4.7 ,2.1 ,0. ,-2.2 ,
	    -4.6 ,-6.8 ,-8.8 ,-10.8 ,-12.9 ,-14.9 ,-16.9 ,-18.9 ,-20.9 ,81.3 ,
	    72.6 ,64.5 ,58. ,52.4 ,48. ,44.3 ,40.7 ,37.3 ,33.8 ,30.3 ,27. ,
	    23.7 ,20.5 ,17.4 ,14.7 ,12. ,9.2 ,6.5 ,4. ,1.8 ,-.4 ,-2.8 ,-5. ,
	    -7. ,-9. ,-11. ,-13. ,-15. ,-16.8 ,-18.6 ];

	
/*  TVFMFS:  DATA TABLE INITIALIZATION OK, CONTINUE WITH PROGRAM   */

// ========The following data is needed for fzq to calculate F(50,90) or other curves ================//

var VGRID = [ .01,.02,.03,.04,.05,.06,.07,.08,.09,.1,.15,.2,.3,.4,.5,.6,.7,.8,.9,1.,1.2,1.4,1.6,1.8,2.,3.,4.,5.,6.,7.,8.,9.,10.,11.,12.,13.,14.,15.,16.,17.,18.,19.,20.,22.,24.,26.,28.,30.,32.,34.,36.,38.,40.,42.,44.,46.,48.,50.,52.,54.,56.,58.,60.,62.,64.,66.,68.,70.,72.,74.,76.,78.,80.,81.,82.,83.,84.,85.,86.,87.,88.,89.,90.,91.,92.,93.,94.,95.,96.,97.,98.,98.2,98.4,98.6,98.8,99.,99.1,99.2,99.3,99.4,99.5,99.6,99.7,99.8,99.85,99.9,99.91,99.92,99.93,99.94,99.95,99.96,99.97,99.98,99.99 ];

var ZGRI  = [ -3.71902,-3.54008,-3.43161,-3.35279,-3.29053,-3.23888,-3.19465,-3.15591,-3.12139,-3.09023,-2.96774,-2.87816,-2.74778,-2.65207,-2.57583,-2.51214,-2.45726,-2.40892,-2.36562,-2.32635,-2.25713,-2.19729,-2.14441,-2.09693,-2.05375,-1.88079,-1.75069,-1.64485,-1.55477,-1.47579,-1.40507,-1.34076,-1.28155,-1.22653,-1.17499,-1.12639,-1.08032,-1.03643,-.99446,-.95416,-.91537,-.8779,-.84162,-.77219,-.7063,-.64335,-.58284,-.5244,-.4677,-.41246,-.35846,-.30548,-.25335,-.20189,-.15097,-.10043,-.05015 ];


/*
//------- ITPLBV --------------------------------------------------------------------------------------------------
// Interpolation subroutine, this is a bi-variate surface fitting procedure, refer to the original FCC CURVES program
// and to the paper referenced in comments above for details.  Sorry about the shortage of comments, but there were
// none in the original source.

// This has been modified from the original, taking into account the context in which it is being used.  It was a full
// general-purpose routine, however many of the conditions that had exception-handling could never have occurred given
// the limited range of possible values in context.  Much of that unnecessary code has been eliminated.

// Arguments:

//    lx  Number of columns in table.
//    ly  Number of rows in table.
//    x   Column enumeration values.
//    y   Row enumeration values.
//    z   Data table.
//    n   Number of points to lookup.
//    u   Column values for lookup points.
//    v   Row values for lookup points.
//    w   Return result of lookups.
*/


function itplbv(lx, ly, x, y, z, n, u, v, w)
{

    // declarations and initializations

       	
        var lxm1,  lxp1,  lym1,  lyp1,  ixpv,  iypv,  k,  ix,  iy,  imn,  imx,  jx,  jy,  jx1,  jy1;
            lxm1 = lxp1 = lym1 = lyp1 = ixpv = iypv = k = ix = iy = imn = imx = jx = jy = jx1 = jy1 = 0;

        var za_row0  = [0, 0]; 
        var za_row1  = [0, 0];
        var za_row2  = [0, 0];
        var za_row3  = [0, 0];
        var za_row4  = [0, 0];
        var za       = [za_row0, za_row1, za_row2, za_row3, za_row4];   // za[5,2]

        var zb_row0  = [0, 0, 0, 0, 0];
        var zb_row1  = [0, 0, 0, 0, 0];
        var zb       = [zb_row0, zb_row1];                              // zb[2,5]

        var zab_row0 = [0, 0, 0];
        var zab_row1 = [0, 0, 0];
        var zab_row2 = [0, 0, 0];
        var zab      = [zab_row0, zab_row1, zab_row2];                  // zab[3,3]

        var zx_row0  = [0, 0, 0, 0];  
        var zx_row1  = [0, 0, 0, 0];  
        var zx_row2  = [0, 0, 0, 0];  
        var zx_row3  = [0, 0, 0, 0];
        var zx       = [zx_row0, zx_row1, zx_row2, zx_row3];            // zx[4,4]

        var zy_row0  = [0, 0, 0, 0];  
        var zy_row1  = [0, 0, 0, 0];  
        var zy_row2  = [0, 0, 0, 0];  
        var zy_row3  = [0, 0, 0, 0];
        var zy       = [zy_row0, zy_row1, zy_row2, zy_row3];            // zy[4,4]  

        var zxy_row0 = [0, 0, 0, 0];  
        var zxy_row1 = [0, 0, 0, 0];  
        var zxy_row2 = [0, 0, 0, 0];  
        var zxy_row3 = [0, 0, 0, 0];
        var zxy      = [zxy_row0, zxy_row1, zxy_row2, zxy_row3];        // zy[4,4]  


        var x3,  x4,  a3,  y3,  y4,  b3,  z33,  z43,  z34,  z44,  x2,  a2,  z23,  z24,  x5,  a4,  z53,  z54; 
            x3 = x4 = a3 = y3 = y4 = b3 = z33 = z43 = z34 = z44 = x2 = a2 = z23 = z24 = x5 = a4 = z53 = z54 = 0.0;

        var a1,  a5,  y2,  b2,  z32,  z42,  y5,  b4,  z35,  z45,  b1,  b5,  w2,  w3,  sw,  wx2,  wx3,  wy2,  wy3,  w1,  w4,  w5; 
            a1 = a5 = y2 = b2 = z32 = z42 = y5 = b4 = z35 = z45 = b1 = b5 = w2 = w3 = sw = wx2 = wx3 = wy2 = wy3 = w1 = w4 = w5 = 0.0; 

        var zx3b3,  zx4b3,  zy3a3,  zy4a3,  a,  b,  c,  d,  e,  a3sq,  b3sq,  p02,  p03,  p12,  p13,  p20,  p21,  p22;
            zx3b3 = zx4b3 = zy3a3 = zy4a3 = a = b = c = d = e = a3sq = b3sq = p02 = p03 = p12 = p13 = p20 = p21 = p22 = 0.0;

        var p23,  p30,  p31,  p32,  p33,  dy,  q0,  q1,  q2,  q3,  dx;
            p23 = p30 = p31 = p32 = p33 = dy = q0 = q1 = q2 = q3 = dx = 0.0;


   

    // Calculations begin 

     
        lx = Math.floor(lx);
        ly = Math.floor(ly);


	lxm1 = Math.floor(lx - 1);         
	lxp1 = Math.floor(lx + 1);
	lym1 = Math.floor(ly - 1);
	lyp1 = Math.floor(ly + 1);                      
	ixpv = -1;
	iypv = -1;
	for (k = 0; k < n; k++) {
		if (u[k] >= x[lxm1]) {       
			ix = lx;
		} else {
			if (u[k] < x[0]) {
				ix = 0;
			} else {
				imn = 1;
				imx = lxm1;
				do {
					ix = Math.floor((imn + imx) / 2);
					if (u[k] >= x[ix]) {
						imn = ix + 1;
					} else {
						imx = ix;
					}
				} while (imx > imn);
				ix = imx;
			}
		}
                ix = Math.floor(ix);

  
		if (v[k] >= y[lym1]) {
			iy = ly;
		} else {
			if (v[k] < y[0]) {
				iy = 0;
			} else {
				imn = 1;
				imx = lym1;
				do {
					iy = Math.floor((imn + imx) / 2);
					if (v[k] >= y[iy]) {
						imn = iy + 1;
					} else {
						imx = iy;
					}
				} while (imx > imn);
				iy = imx;
			}
		}
                iy = Math.floor(iy);


		if ((ix != ixpv) || (iy != iypv)) {  
			ixpv = ix;
			iypv = iy;
			if (ix == 0) {
				jx = 1;
			} else {
				if (ix == lx) {
					jx = lxm1;
				} else {
					jx = ix;
				}
			}
			if (iy == 0) {
				jy = 1;
			} else {
				if (iy == ly) {
					jy = lym1;
				} else {
					jy = iy;
				}
			}
                        jx = Math.floor(jx);
                        jy = Math.floor(jy);

			x3 = x[jx - 1];                 
			x4 = x[jx];
			a3 = 1. / (x4 - x3);
			y3 = y[jy - 1];
			y4 = y[jy];                                   
			b3 = 1. / (y4 - y3);
			z33 = z[(jx - 1) + ((jy - 1) * lx)];
			z43 = z[jx + ((jy - 1) * lx)];
			z34 = z[(jx - 1) + (jy * lx)];
			z44 = z[jx + (jy * lx)];
			za[2][0] = (z43 - z33) * a3;
			za[2][1] = (z44 - z34) * a3;
			zb[0][2] = (z34 - z33) * b3;
			zb[1][2] = (z44 - z43) * b3;
			zab[1][1] = (zb[1][2] - zb[0][2]) * a3;
			if (jx > 1) {
				x2 = x[jx - 2];
				a2 = 1. / (x3 - x2);
				z23 = z[(jx - 2) + ((jy - 1) * lx)];
				z24 = z[(jx - 2) + (jy * lx)];
				za[1][0] = (z33 - z23) * a2;
				za[1][1] = (z34 - z24) * a2;
				if (jx == lxm1) {
					za[3][0] = (2. * za[2][0]) - za[1][0];
					za[3][1] = (2. * za[2][1]) - za[1][1];
				}
			}

			if (jx < lxm1) {
				x5 = x[jx + 1];
				a4 = 1. / (x5 - x4);
				z53 = z[(jx + 1) + ((jy - 1) * lx)];
				z54 = z[(jx + 1) + (jy * lx)];
				za[3][0] = (z53 - z43) * a4;
				za[3][1] = (z54 - z44) * a4;
				if (jx == 1) {
					za[1][0] = (2. * za[2][0]) - za[3][0];
					za[1][1] = (2. * za[2][1]) - za[3][1];
				}
			}

			zab[0][1] = (za[1][1] - za[1][0]) * b3;
			zab[2][1] = (za[3][1] - za[3][0]) * b3;
			if (jx > 2) {
				a1 = 1. / (x2 - x[jx - 3]);
				za[0][0] = (z23 - z[(jx - 3) + ((jy - 1) * lx)]) * a1;
				za[0][1] = (z24 - z[(jx - 3) + (jy * lx)]) * a1;
			} else {
				za[0][0] = (2. * za[1][0]) - za[2][0];
				za[0][1] = (2. * za[1][1]) - za[2][1];
			}
			if (jx < (lx - 2)) {
				a5 = 1. / (x[jx + 2] - x5);
				za[4][0] = (z[(jx + 2) + ((jy - 1) * lx)] - z53) * a5;
				za[4][1] = (z[(jx + 2) + (jy * lx)] - z54) * a5;
			} else {
				za[4][0] = (2. * za[3][0]) - za[2][0];
				za[4][1] = (2. * za[3][1]) - za[2][1];
			}
			if (jy > 1) {
				y2 = y[jy - 2];
				b2 = 1. / (y3 - y2);
				z32 = z[(jx - 1) + ((jy - 2) * lx)];
				z42 = z[jx + ((jy - 2) * lx)];
				zb[0][1] = (z33 - z32) * b2;
				zb[1][1] = (z43 - z42) * b2;
				if (jy == lym1) {
					zb[0][3] = (2. * zb[0][2]) - zb[0][1];
					zb[1][3] = (2. * zb[1][2]) - zb[1][1];
				}
			}
			if (jy < lym1) {
				y5 = y[jy + 1];
				b4 = 1. / (y5 - y4);
				z35 = z[(jx - 1) + ((jy + 1) * lx)];
				z45 = z[jx + ((jy + 1) * lx)];
				zb[0][3] = (z35 - z34) * b4;
				zb[1][3] = (z45 - z44) * b4;
				if (jy == 1) {
					zb[0][1] = (2. * zb[0][2]) - zb[0][3];
					zb[1][1] = (2. * zb[1][2]) - zb[1][3];
				}
			}
			zab[1][0] = (zb[1][1] - zb[0][1]) * a3;
			zab[1][2] = (zb[1][3] - zb[0][3]) * a3;   
			if (jy > 2) {
				b1 = 1. / (y2 - y[jy - 3]);
				zb[0][0] = (z32 - z[(jx - 1) + ((jy - 3) * lx)]) * b1;
				zb[1][0] = (z42 - z[jx + ((jy - 3) * lx)]) * b1;
			} else {
				zb[0][0] = (2. * zb[0][1]) - zb[0][2];
				zb[1][0] = (2. * zb[1][1]) - zb[1][2];
			}
			if (jy < (ly - 2)) {
				b5 = 1. / (y[jy + 2] - y5);
				zb[0][4] = (z[(jx - 1) + ((jy + 2) * lx)] - z35) * b5;
				zb[1][4] = (z[jx + ((jy + 2) * lx)] - z45) * b5;
			} else {
				zb[0][4] = (2. * zb[0][3]) - zb[0][2];
				zb[1][4] = (2. * zb[1][3]) - zb[1][2];
			}
			if (jx < lxm1) {
				if (jy > 1) {
					zab[2][0] = ((z53 - z[(jx + 1) + ((jy - 2) * lx)]) * b2 - zb[1][1]) * a4;
					if (jy < lym1) {
						zab[2][2] = ((z[(jx + 1) + ((jy + 1) * lx)] - z54) * b4 - zb[1][3]) * a4;
					} else {
						zab[2][2] = (2. * zab[2][1]) - zab[2][0];
					}
				} else {
					zab[2][2] = ((z[(jx + 1) + ((jy + 1) * lx)] - z54) * b4 - zb[1][3]) * a4;
					zab[2][0] = (2. * zab[2][1]) - zab[2][2];
				}
				if (jx == 1) {
					zab[0][0] = (2. * zab[1][0]) - zab[2][0];
					zab[0][2] = (2. * zab[1][2]) - zab[2][2];
				}
			}
			if (jx > 1) {
				if (jy > 1) {
					zab[0][0] = (zb[0][1] - (z23 - z[(jx - 2) + ((jy - 2) * lx)]) * b2) * a2;
					if (jy < lym1) {
						zab[0][2] = (zb[0][3] - (z[(jx - 2) + ((jy + 1) * lx)] - z24) * b4) * a2;
					} else {
						zab[0][2] = (2. * zab[0][1]) - zab[0][0];
					}
				} else {
					zab[0][2] = (zb[0][3] - (z[(jx - 2) + ((jy + 1) * lx)] - z24) * b4) * a2;
					zab[0][0] = (2. * zab[0][1]) - zab[0][2];
				}
				if (jx == lxm1) {
					zab[2][0] = (2. * zab[1][0]) - zab[0][0];
					zab[2][2] = (2. * zab[1][2]) - zab[0][2];
				}
			}
			for (jy = 1; jy < 3; jy++) {
				for (jx = 1; jx < 3; jx++) {
					w2 = Math.abs(za[jx + 2][jy - 1] - za[jx + 1][jy - 1]);
					w3 = Math.abs(za[jx][jy - 1] - za[jx - 1][jy - 1]);
					sw = w2 + w3;
					if (sw >= 1.e-7) {
						wx2 = w2 / sw;
						wx3 = w3 / sw;
					} else {
						wx2 = 0.5;
						wx3 = 0.5;
					}
					zx[jx][jy] = wx2 * za[jx][jy - 1] + wx3 * za[jx + 1][jy - 1];
					w2 = Math.abs(zb[jx - 1][jy + 2] - zb[jx - 1][jy + 1]);
					w3 = Math.abs(zb[jx - 1][jy] - zb[jx - 1][jy - 1]);
					sw = w2 + w3;
					if (sw >= 1.e-7) {
						wy2 = w2 / sw;
						wy3 = w3 / sw;
					} else {
						wy2 = 0.5;
						wy3 = 0.5;
					}
					zy[jx][jy] = wy2 * zb[jx - 1][jy] + wy3 * zb[jx - 1][jy + 1];
					zxy[jx][jy] = wy2 * (wx2 * zab[jx - 1][jy - 1] + wx3 * zab[jx][jy - 1]) +
						wy3 * (wx2 * zab[jx - 1][jy] + wx3 * zab[jx][jy]);
				}
			}
			if (ix == 0) {
				w2 = a4 * (3. * a3 + a4);
				w1 = 2. * a3 * (a3 - a4) + w2;
				for (jy = 1; jy < 3; jy++) {
					zx[0][jy] = (w1 * za[0][jy - 1] + w2 * za[1][jy - 1]) / (w1 + w2);
					zy[0][jy] = (2. * zy[1][jy]) - zy[2][jy];
					zxy[0][jy] = (2. * zxy[1][jy]) - zxy[2][jy];
					for (jx1 = 1; jx1 < 3; jx1++) {
						jx = 3 - jx1;
						zx[jx][jy] = zx[jx - 1][jy];
						zy[jx][jy] = zy[jx - 1][jy];
						zxy[jx][jy] = zxy[jx - 1][jy];
					}
				}
				x3 -= 1. / a4;
				z33 -= za[1][0] / a4;
				for (jy = 0; jy < 5; jy++) {
					zb[1][jy] = zb[0][jy];
				}
				for (jy = 1; jy < 4; jy++) {
					zb[0][jy] -= zab[0][jy - 1] / a4;
				}
				a3 = a4;
				za[2][0] = za[1][0];
				for (jy = 0; jy < 3; jy++) {
					zab[1][jy] = zab[0][jy];
				}
			}
			if (ix == lx) {
				w4 = a2 * (3. * a3 + a2);
				w5 = 2. * a3 * (a3 - a2) + w4;
				for (jy = 1; jy < 3; jy++) {
					zx[3][jy] = (w4 * za[3][jy - 1] + w5 * za[4][jy - 1]) / (w4 + w5);
					zy[3][jy] = (2. * zy[2][jy]) - zy[1][jy];
					zxy[3][jy] = (2. * zxy[2][jy]) - zxy[1][jy];
					for (jx = 1; jx < 3; jx++) {
						zx[jx][jy] = zx[jx + 1][jy];
						zy[jx][jy] = zy[jx + 1][jy];
						zxy[jx][jy] = zxy[jx + 1][jy];
					}
				}
				x3 = x4;
				z33 = z43;
				for (jy = 0; jy < 5; jy++) {
					zb[0][jy] = zb[1][jy];
				}
				a3 = a2;
				za[2][0] = za[3][0];
				for (jy = 0; jy < 3; jy++) {
					zab[1][jy] = zab[2][jy];
				}
			}
			if (iy == 0) {
				w2 = b4 * (3. * b3 + b4);
				w1 = 2. * b3 * (b3 - b4) + w2;
				for (jx = 1; jx < 3; jx++) {
					if (((ix > 0) || (jx == 2)) && ((ix < lx) || (jx == 1))) {
						zy[jx][0] = (w1 * zb[jx - 1][0] + w2 * zb[jx - 1][1]) / (w1 + w2);
						zx[jx][0] = (2. * zx[jx][1]) - zx[jx][2];
						zxy[jx][0] = (2. * zxy[jx][1]) - zxy[jx][2];
					}
					for (jy1 = 1; jy1 < 3; jy1++) {
						jy = 3 - jy1;
						zy[jx][jy] = zy[jx][jy - 1];
						zx[jx][jy] = zx[jx][jy - 1];
						zxy[jx][jy] = zxy[jx][jy - 1];
					}
				}
				y3 -= 1. / b4;
				z33 -= zb[0][1] / b4;
				za[2][0] -= zab[1][0] / b4;
				zb[0][2] = zb[0][1];
				zab[1][1] = zab[1][0];
				b3 = b4;
				if ((ix == 0) || (ix == lx)) {
					if (ix == 0) {
						jx = 1;
						jx1 = 2;
					} else {
						jx = 2;
						jx1 = 1;
					}
                                        jx1 = Math.floor(jx1);
					zx[jx][1] = zx[jx1][1] + zx[jx][2] - zx[jx1][2];
					zy[jx][1] = zy[jx1][1] + zy[jx][2] - zy[jx1][2];
					zxy[jx][1] = zxy[jx1][1] + zxy[jx][2] - zxy[jx1][2];
				}
			}
			if (iy == ly) {
				w4 = b2 * (3. * b3 + b2);
				w5 = 2. * b3 * (b3 - b2) + w4;
				for (jx = 1; jx < 3; jx++) {
					if (((ix > 0) || (jx == 2)) && ((ix < lx) || (jx == 1))) {
						zy[jx][3] = (w4 * zb[jx - 1][3] + w5 * zb[jx - 1][4]) / (w4 + w5);
						zx[jx][3] = (2. * zx[jx][2]) - zx[jx][1];
						zxy[jx][3] = (2. * zxy[jx][2]) - zxy[jx][1];
					}
					for (jy = 1; jy < 3; jy++) {
						zy[jx][jy] = zy[jx][jy + 1];
						zx[jx][jy] = zx[jx][jy + 1];
						zxy[jx][jy] = zxy[jx][jy + 1];
					}
				}
				y3 = y4;
				z33 += zb[0][2] / b3;
				za[2][0] += zab[1][1] / b3;
				zb[0][2] = zb[0][3];
				zab[1][1] = zab[1][2];
				b3 = b2;
				if ((ix == 0) || (ix == lx)) {
					if (ix == 0) {
						jx = 1;
						jx1 = 2;
					} else {
						jx = 2;
						jx1 = 1;
					}
					zx[jx][2] = zx[jx1][2] + zx[jx][1] - zx[jx1][1];
					zy[jx][2] = zy[jx1][2] + zy[jx][1] - zy[jx1][1];
					zxy[jx][2] = zxy[jx1][2] + zxy[jx][1] - zxy[jx1][1];
				}
			}
			zx3b3 = (zx[1][2] - zx[1][1]) * b3;
			zx4b3 = (zx[2][2] - zx[2][1]) * b3;
			zy3a3 = (zy[2][1] - zy[1][1]) * a3;
			zy4a3 = (zy[2][2] - zy[1][2]) * a3;
			a = zab[1][1] - zx3b3 - zy3a3 + zxy[1][1];
			b = zx4b3 - zx3b3 - zxy[2][1] + zxy[1][1];
			c = zy4a3 - zy3a3 - zxy[1][2] + zxy[1][1];
			d = zxy[2][2] - zxy[2][1] - zxy[1][2] + zxy[1][1];
			e = a + a - b - c;
			a3sq = a3 * a3;
			b3sq = b3 * b3;
			p02 = (2. * (zb[0][2] - zy[1][1]) + zb[0][2] - zy[1][2]) * b3;
			p03 = (-2. * zb[0][2] + zy[1][2] + zy[1][1]) * b3sq;
			p12 = (2. * (zx3b3 - zxy[1][1]) + zx3b3 - zxy[1][2]) * b3;
			p13 = (-2. * zx3b3 + zxy[1][2] + zxy[1][1]) * b3sq;
			p20 = (2. * (za[2][0] - zx[1][1]) + za[2][0] - zx[2][1]) * a3;
			p21 = (2. * (zy3a3 - zxy[1][1]) + zy3a3 - zxy[2][1]) * a3;
			p22 = (3. * (a + e) + d) * a3 * b3;
			p23 = (-3. * e - b - d) * a3 * b3sq;
			p30 = (-2. * za[2][0] + zx[2][1] + zx[1][1]) * a3sq;
			p31 = (-2. * zy3a3 + zxy[2][1] + zxy[1][1]) * a3sq;
			p32 = (-3. * e - c - d) * b3 * a3sq;
			p33 = (d + e + e) * a3sq * b3sq;
		}
		dy = v[k] - y3;
		q0 = z33 + dy * (zy[1][1] + dy * (p02 + dy * p03));
		q1 = zx[1][1] + dy * (zxy[1][1] + dy * (p12 + dy * p13));
		q2 = p20 + dy * (p21 + dy * (p22 + dy * p23));
		q3 = p30 + dy * (p31 + dy * (p32 + dy * p33));
		dx = u[k] - x3;
		w[k] = q0 + dx * (q1 + dx * (q2 + dx * q3));

        }
      
}  // end itplbv function ---------------------------------------------------------------------


function tvfmfs_metric(erp, haat, channel, field, distance, fs_or_dist, curve, flag)
{
  var id50 = 25;
  var ih50 = 13;
  var id10 = 31;
  var ih10 = 13;
  var range = 100.;
  var delta = 0.5;
  var erp_db = 0.0;
  var d_first = 0.0;
  var d_last = 0.0;
  var e_volts_meter = 0.0;
  var n_points = 1001;
 

  //var erp_copy = erp;
  //var distance_copy = distance;
  //var field_copy = field;
    
  var i = 0;
  var j = 1;

  var d = []; 
  var h = [];  
  var f = []; 
  var f5050 = [];   
  var f5010 = []; 

  //For F(50,90) curves 
  var L = 50.0;
  var T = 90.0;
  var ZQ = 0.0;
  var sigma = 0.0;
  var RL = 0.0;
  var RT = 0.0;

      //var flag = [];
	  
	  for(i=0; i < 19;  i++)  flag[i] = 0;
 

      // Input data checks

         if ((channel < 2 || channel > 300) || (channel > 69 && channel < 200) || channel == '') { flag[3] = 1; }
	  if (erp < 0.0001)  
             { 
                flag[6] = 1;
                if(erp < 0.0001 && erp > 0.00000001) { erp = 0.0001; }
             }

         if (((channel >= 2 && channel <= 6) || (channel >= 200 && channel <= 300)) && (erp > 400.5)) { flag[12] = 1; }
         else if ((channel >= 7  && channel <= 13) && (erp > 400.5))    { flag[13] = 1; }
         else if ((channel >= 14 && channel <= 69) && (erp > 5500.5))   { flag[14] = 1; }

         if     ((curve == 0 || curve == 2) && distance > 300.) { flag[15] = 1; }
         else if (curve == 1 && distance > 500.) { flag[16] = 1; }
 	  
	   if (curve < 0  || curve > 2 || curve === '')                  { flag[4] = 1; }
	   if (fs_or_dist < 1 || fs_or_dist > 3 || fs_or_dist == '')    { flag[5] = 1; }
          if (fs_or_dist == 1 && field < 0.0)      { flag[9] = 1; field    = Math.abs(field);    }
          if (fs_or_dist == 2 && distance < 0.0)   { flag[9] = 1; distance = Math.abs(distance); }
    
          if (fs_or_dist == 3)  //find FM ERP, given a HAAT and a distance
             {   
				var field_for_erp = 60.;       // 60 dBu used to determin equivalence
                erp = 1.0;                     // initial value
                if(channel < 200) flag[17]=1;  // No TV calculations here
                curve = 0;                     // Service contour only
                //channel = 250;
             }

         erp_db = 10.0 * (Math.log(erp)/Math.log(10));  
         // Math.log(x)/Math.log(10) = log10(x) which is not supported in some browsers
         
         if (haat < 30.0)       { haat = 30.0;  flag[7] = 1; }  // All HAAT below 30 meters are set to 30
         else if (haat > 1600)  { haat = 1600.; flag[8] = 1; }  // All HAAT above 1600 are set to 1600

         if(flag[3]==1 || flag[4]==1 || flag[5]==1) { return flag; } //need more info -- NO CALCULATIONS
         else if(flag[12]==1 || flag[13]==1 || flag[14]==1 || flag[15]==1 || flag[16]==1 || flag[17]==1) { return flag; } //need more info -- NO CALCULATIONS

/***********************************************************************
!     FOR fs_or_dist = 1, FIND THE "FIELD" AT THE DISTANCE SPECIFIED IN    *
!     "DISTANCE".  IF THE DISTANCE IS LESS THAN 1.5 KM, USE THE FREE   *
!     SPACE EQUATION.                                                  *
!**********************************************************************/


  
      if (fs_or_dist == 1 || fs_or_dist == 3) 
	  {

	       n_points = 1;
              j = 1;
              if (distance < 1.5) 
		  {
                    field = (106.92 - (20.0 * (Math.log(distance)/Math.log(10)))) + erp_db;
                       // Math.log(x)/Math.log(10) = log10(x) which is not supported in some browsers (Internet Explorer)

                    flag[1] = 1;

                    return field;

         	  }
	      if ((curve == 0 && distance > 300.0) || (curve == 1 && distance > 500.0)) 
                  {
		    flag[2] = 1;
                  }
              else
                  {
                    h[0] = haat;       // Only one point sought
                    d[0] = distance;
          
                    RL = 0.0;

	            if ((channel >= 2 && channel <= 6) || (channel >= 200 && channel <= 300)) // FM & analog TV channels 2-6
	              {
                        if (curve == 0 || (curve == 1 && distance < 15.0))
		         {
                           itplbv(id50, ih50, D50, H50, F55LV, j, d, h, f);
  		         }
                        else if (curve == 1) 
		         {
                           itplbv(id10, ih10, D10, H10, F51LV, j, d, h, f);
                         }
                        else if (curve == 2)
                         {
                           if(distance >= 15)
                            {
                              itplbv(id50, ih50, D50, H50, F55LV, j, d, h, f5050);
                              itplbv(id10, ih10, D10, H10, F51LV, j, d, h, f5010);
                            }
                           else if(distance < 15)
                            {
                              itplbv(id50, ih50, D50, H50, F55LV, j, d, h, f5050);
                              f5010[0] = f5050[0]; // use F5050 curves below 15 km
                            } 

                            // F(50,90) means field strength at 50% of the locations, 90% of the time
                            // Here we can alter the location variability parameter L.  This changes the field strength result.
                            // But since in practice, we never use this, it is commented out.  
                            // It is retained here for reference only.
                        
                            // if( L != 50. )
                            // {
                            //  ZQ = fzq(L); 
                            //  sigma = 11.88; // > 470 MHz
                            //  RL = ZQ * sigma;
                            // } 
                        }
                   }
                   else if (channel >= 7 && channel <= 13)
	           {
                       if (curve == 0 || (curve == 1 && distance < 15.0))
		         {
                           itplbv(id50, ih50, D50, H50, F55HV, j, d, h, f);
		         }
                       else if (curve == 1) 
		         {
                           itplbv(id10, ih10, D10, H10, F51HV, j, d, h, f);
		         }
                       else if (curve==2)
                         {
                            if(distance >= 15)
                            {
                               itplbv(id50, ih50, D50, H50, F55HV, j, d, h, f5050);
                               itplbv(id10, ih10, D10, H10, F51HV, j, d, h, f5010);
                            }
                           else if(distance < 15)
                            {
                              itplbv(id50, ih50, D50, H50, F55HV, j, d, h, f5050);
                              f5010[0] = f5050[0]; // use F5050 curves below 15 km
                            } 

                            // F(50,90) means field strength at 50% of the locations, 90% of the time
                            // Here we can alter the location variability parameter L.  This changes the field strength result.
                            // But since in practice, we never use this, it is commented out.  
                            // It is retained here for reference only.
                        
                            // if( L != 50. )
                            // {
                            //  ZQ = fzq(L); 
                            //  sigma = 11.88; // > 470 MHz
                            //  RL = ZQ * sigma;
                            // } 
                        }

	             }
                  else if (channel >= 14 && channel <= 69) 
	             {
                       if (curve == 0 || (curve == 1 &&  distance < 15.0)) //F(50,50)
		         { 
                           itplbv(id50, ih50, D50, H50, F55U, j, d, h, f);
		         }
                       else if (curve == 1) // F(50,10)
		        {
                           itplbv(id10, ih10, D10, H10, F51U, j, d, h, f);
		        }
                    else if (curve==2)  // F(50,90)
                        {
                           if(distance >= 15)
                           {
                              itplbv(id50, ih50, D50, H50, F55U, j, d, h, f5050);
                              itplbv(id10, ih10, D10, H10, F51U, j, d, h, f5010);
                           }
                           else if(distance < 15)
                           {
                              itplbv(id50, ih50, D50, H50, F55U, j, d, h, f5050);
                              f5010[0] = f5050[0]; // use F5050 curves below 15 km
                            }

                            // F(50,90) means field strength at 50% of the locations, 90% of the time
                            // Here we can alter the location variability parameter L.  This changes the field strength result.
                            // But since in practice, we never use this, it is commented out.  
                            // It is retained here for reference only.
                        
                            // if( L != 50. )
                            // {
                            //  ZQ = fzq(L); 
                            //  sigma = 11.88; // > 470 MHz
                            //  RL = ZQ * sigma;
                            // } 
                        }
                  }
              }
             if(flag[1] == 1)
                {  ;  }  // no changes to field value
	      if(curve==0 || curve == 1) 
                { 
                  field = f[0] + erp_db; 
                } 
             else if(curve == 2)
                {
                  ZQ = fzq(T);
                  
                  RT = (f5010[0] - f5050[0]) * (ZQ/1.28155);
                
                  field = f5050[0] + RL + RT + erp_db;
                }

            if(fs_or_dist == 3)  // then we find the FM ERP in kW and return that
            {
               erp = Math.pow(10,((field_for_erp - field)/10.));

               if(erp > 100) flag[10] = 1;

               return erp;
            }
            else
            {
               return field;
            }
	        
           
	  } // end fs_or_dist == 1

/***********************************************************************
!     FOR fs_or_dist = 2, THE "DISTANCE" FOR A SPECIFIED "FIELD" VALUE IS
!     FOUND BY COMPUTING A FIELD VS. DISTANCE CURVE AT
!     INCREMENTS OF 0.5 KILOMETER AND THEN FINDING THE CORRECT DISTANCE VALUE
!     BY  INTERPOLATING BETWEEN THE FIELD POINTS.                          
!***********************************************************************/

      else if (fs_or_dist == 2)
      {
	  
	           //console.log('erp=', erp)
               j = n_points;

               for (i = 0; i <= n_points; i++)   { h[i] = haat; f5050[i] = f5010[i] = f[i] = d[i] = 0.0; }
  
               if (curve == 0 || curve == 2 )
                {   d_first = 1.5;   d_last  = 300.0;   }
               else if (curve == 1) 
                {   d_first = 15.0;  d_last  = 500.0;   }
               var k = Math.floor(d_first/delta);
               for(i=k; i <= n_points; i++)  { d[i] = (i * delta);  }  // d_first/delta must be an integer

 //continue110:
 
              if ((channel >= 2 && channel <= 6) || (channel >= 200 && channel <= 300)) 
                {
                  if (curve == 0) 
                   {
                     itplbv(id50, ih50, D50, H50, F55LV, j, d, h, f);
                   }
                  else if (curve == 1) 
                   {
                     itplbv(id10, ih10, D10, H10, F51LV, j, d, h, f);
                   }
                  else if (curve == 2)
                   {
                         itplbv(id50, ih50, D50, H50, F55LV, j, d, h, f5050);
                         itplbv(id10, ih10, D10, H10, F51LV, j, d, h, f5010);
 
                         // F(50,90) means field strength at 50% of the locations, 90% of the time
                         // Here we can alter the location variability parameter L.  This changes the field strength result.
                         // But since in practice, we never use this, it is commented out.  
                         // It is retained here for reference only.
                        
                         // if( L != 50. )
                         // {
                         //  ZQ = fzq(L); 
                         //  sigma = 11.88; // > 470 MHz
                         //  RL = ZQ * sigma;
                   } 

                }
              else if (channel >=7 && channel <= 13) 
                {
                  if (curve == 0) 
                   {
                     itplbv(id50, ih50, D50, H50, F55HV, j, d, h, f);
                   }
                  else if (curve == 1) 
                   {
                     itplbv(id10, ih10, D10, H10, F51HV, j, d, h, f);
                   }
                  else if (curve==2)
                   {
                         itplbv(id50, ih50, D50, H50, F55HV, j, d, h, f5050);
                         itplbv(id10, ih10, D10, H10, F51HV, j, d, h, f5010);

                         // F(50,90) means field strength at 50% of the locations, 90% of the time
                         // Here we can alter the location variability parameter L.  This changes the field strength result.
                         // But since in practice, we never use this, it is commented out.  
                         // It is retained here for reference only.
                        
                         // if( L != 50. )
                         // {
                         //  ZQ = fzq(L); 
                         //  sigma = 11.88; // > 470 MHz
                         //  RL = ZQ * sigma;
                    } 

                }
              else if (channel >= 14 && channel <= 69)
               {
                  if (curve == 0) 
                   {
                     itplbv(id50, ih50, D50, H50, F55U, j, d, h, f);
                   }
                  else if (curve == 1) 
                   {
                     itplbv(id10, ih10, D10, H10, F51U, j, d, h, f);
                   }
                  else if (curve==2)
                   {
                        itplbv(id50, ih50, D50, H50, F55U, j, d, h, f5050);
                        itplbv(id10, ih10, D10, H10, F51U, j, d, h, f5010);

                         // F(50,90) means field strength at 50% of the locations, 90% of the time
                         // Here we can alter the location variability parameter L.  This changes the field strength result.
                         // But since in practice, we never use this, it is commented out.  
                         // It is retained here for reference only.
                        
                         // if( L != 50. )
                         // {
                         //  ZQ = fzq(L); 
                         //  sigma = 11.88; // > 470 MHz
                         //  RL = ZQ * sigma;
                    }
               }

              if(curve == 1 || curve == 2)  // add in the 3 to 15 km range to the f field strength array 
                              // for F(50,10) interfering contours only.  Since the F(50,10) interfering 
                              // contours start at 15 km, we use the F(50,50) curves in this range.					 
               {
                    var d1 = [];
                    var f1 = [];  //alert(channel);
  
                    for(i=0; i < 30; i++) f[i] = 0.0;
                    for(i=0; i < n_points; i++) {  d1[i] = (i * delta); f1[i] = 0.0; }
 
                    if((channel >= 2 && channel <= 6) || (channel >= 200 && channel <= 300))
                         {  itplbv(id50, ih50, D50, H50, F55LV, j, d1, h, f1); }
                    else if(channel >= 7 && channel <= 13)
                         {  itplbv(id50, ih50, D50, H50, F55HV, j, d1, h, f1); }
                    else if(channel >= 14 && channel <= 69)
                         {  itplbv(id50, ih50, D50, H50, F55U,  j, d1, h, f5050); }
                     
                   //i=i for FM vhf uhf

                   for(i=0; i < 30; i++)
                    {
                       if(curve == 1)         {  f[i] = f1[i] * 1.0;    }
                       else if(curve == 2)    {  f[i] = f5010[i] = f5050[i] * 1.0; }
 
                       d[i] = (i * delta);
                    } 

 //  for(i=0; i<35; i++) document.write(f[i] + '  ' + i + '  ' + f1[i] + '  ' + d[i] + '<br>');


              }

			//console.log('here, field=', field, 'f0=', f[0], 'f1=', f[1], 'f2=', f[2])

           for(i=3; i > 0; i--)  // i = 2,1 0 (3 points) 1.5, 1, 0.5
             {
             if(field > f[i])  // High field strength, very close to transmitter site // Service AND Interfering contours.
               {               // Use the free space equation to find the field strength and distance
			   
			         
                      flag[1] = 1; 
                      e_volts_meter =  1.0e-6 * Math.pow(10,(field / 20.));
                      distance = (7.014271e-3 * Math.sqrt(erp * 1000.)) / e_volts_meter;
					                      
                      // Added 9/2004 to prevent free space distance from exceeding minimum curves distance of 
                      // 1.5 km (to eliminate the discontinuity between the free space and curves values)
                        
                     // if(distance >= 1.5) { distance = 1.5; flag[1] = 0; }

                      return distance;
                  }
             }                

       
             for(i = 0; i < n_points; i++) // points i=0,1,2 covered by free space equation immediately above
              {
                  if(curve == 0 || curve == 1)
                  { 
                     f[i] = f[i] + erp_db;
                  }
                  else if(curve==2)
                  {
                    ZQ = fzq(T);  // T is the time variable in F(50,90) = the 90 
                    RT = (f5010[i] - f5050[i]) * (ZQ/1.28155);
                
                    f[i] = f5050[i] + RL + RT + erp_db;
                  }     
              } 
              
             // Most common, for service and interfering contours             
  
             for(i = 1; i < n_points; i++)  // start at 1
             {
               if (field > f[i] && field < f[i-1]) 
               {
                   // TEST alert(i + '  '  + field +'  ' + f[i-1] + '  ' + f[i] + '  ' + d[i] + '  ' + d[i-1]);   
                 
                   distance = (((f[i-1] - field) / (f[i-1] - f[i])) * (d[i] - d[i-1])) + d[i-1];

				   //console.log('i', i, 'dist', distance)
                   if (distance > d_last) flag[2] = 1;  

                   return distance;
               }
             }

     // should not get here!

  } // end distance
} // end tvfmfs_metric ----------------------------------------------------------------------------------

function tvfmfs_comment(i)
{
	var comment;
    if(i==0)       comment = "";
    else if(i==1)  comment = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Free Space equation used to compute distance.<br>\n ";
    else if(i==2)  comment = "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entered distance exceeds maximum curve distance.<br>\n";
    else if(i==3)  comment = "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select a channel range.<br>\n";
    else if(i==4)  comment = "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select a contour type.<br>\n";
    else if(i==5)  comment = "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select the desired result (Find This).<br>\n";
    else if(i==6)  comment = "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERP of less than 0.0001 kW (0.1 watt) is changed to 0.0001 kW for calculations.<br>\n";
    else if(i==7)  comment = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entered HAAT is less than 30 meters; changed to 30 meters for calculations.<br>\n";
    else if(i==8)  comment = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entered HAAT is greater than 1600 meters; changed to 1600 meters for calculations.<br>\n";
    else if(i==9)  comment = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entered Field or Distance is less than zero; set to positive for calculations.<br>\n";
    else if(i==10) comment ="&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERP exceeds the maximum of 100 kW permitted for U.S. FM stations. <br>\n";
    else if(i==11) comment ="<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Non-numeric data entered in a form input. <br>\n";

    else if(i==12) comment ="&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum ERP for VHF, TV Channels 2-6, is 400 kW. <br>\n";
    else if(i==13) comment ="&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum ERP for VHF, TV Channels 7-13, is 400 kW. <br>\n";
    else if(i==14) comment ="&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum ERP for UHF, TV Channels 14-69, is 5500 kW. <br>\n";

    else if(i==15) comment ="<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum curve <b>distance</b> for service contours is limited to 300 km. <br>\n";
    else if(i==16) comment ="<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum curve <b>distance</b> for interfering contours is limited to 500 km.<br>\n";
    
    else if(i==17) comment ="<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 'Find ERP' calculation is not valid for the TV service.<br>\n";
	else if(i==18) comment ="&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum ERP for VHF, FM Channel 6, is 400 kW. <br>\n";

	else if(i==19) comment ="Feature not yet implemented."
    else comment=""; 
    return comment;
}


function fzq(Q) // for F(50,90) curves prediction
{
    var k;
    var ZGRID = [];
    
    var ZQ = 0.0; // Initialize
    
    for(k=0; k <= 57; k++)
      {
        ZGRID[k] = -ZGRI[k];
        ZGRID[114-k] = ZGRI[k];
      }
    for(k=1; k < 115; k++)
      {
        if( VGRID[k] < Q ) { ; }
        else
          {
            ZQ = ZGRID[k-1] + (( Q - VGRID[k-1])/(VGRID[k]-VGRID[k-1])) * (ZGRID[k] - ZGRID[k-1]);
            if(ZQ !== ZQ) ZQ = 0.0;  // Checking for NaN, set to 0 (means no curve shifts for Q)
            return ZQ;
          }
      }

}   // end fzq  

function round_power(power_in, error_flag)
{

	/************************************************************************
	*
	*     This subroutine will round the power in accordance with the FCC
	*     Rules section 73.212.
	*
	*     POWER_IN   = Unrounded power in Watts or kilowatts; real; input.
	*     POWER_OUT  = Rounded power in Watts or kilowatts; real; output.
	*     ERROR_FLAG = 0; no errors; integer; output.
	*                = 1; Input power is less than minimum allowed,
	*                     POWER_OUT set equal to POWER_IN.
	*                = 2; Input power greater than maximum allowed,
	*                     POWER_OUT set equal to POWER_IN.
	*
	*                     ...kalagian...11/3/86...
	*
	***********************************************************************/

      var power_out = 0.0;
      var round_factor = 0.0;

      var error_flag = 0;
      power_out = power_in + 0.000000000001;  // to insure a nonzero power_in

      if (power_in >= 0.001 && power_in < 0.003)     {  round_factor = 0.00005; }    

      else if (power_in >= 0.003 && power_in < 0.01) {  round_factor = 0.0001;  }

      else if (power_in >= 0.01 && power_in < 0.03)  {  round_factor = 0.0005;  }

      else if (power_in >= 0.03 && power_in < 0.1)   {  round_factor = 0.001;   }    

      else if (power_in >= 0.10 && power_in < 0.3)   {  round_factor = 0.005;   } 

      else if (power_in >= 0.30 && power_in < 1.0)   {  round_factor = 0.01;    } 

      else if (power_in >= 1.0 && power_in < 3.0)    {  round_factor = 0.05;    } 

      else if (power_in >= 3.00 && power_in < 10.)  {  round_factor = 0.1;     }   

      else if (power_in >= 10.0 && power_in < 30.)   {  round_factor = 0.5;     }  

      else if (power_in >= 30. && power_in < 100.)   {  round_factor = 1.;      } 

      else if (power_in >= 100. && power_in < 300.)  {  round_factor = 5.;      }    

      else if (power_in >= 300. && power_in < 1000.) {  round_factor = 10.0;    }

         power_out = power_in / round_factor;
	  power_out = Math.floor(Math.round(power_out));
	  power_out = power_out * round_factor;

      if (power_in > 1000.)  { power_out = Math.floor(power_in); } 

      return(power_out);
}   

function getResult(req, res, callback) {
	console.log('================ Start CURVES API ===================');
	/*
	 * Refactored 6/20/18 by Sam Bressi
	 * Instead of calling getDistance directly, the input validations
	 *  are wrapped in a getResults wrapper, which adds in the computationMethod.
	 * 
	 * The computationMethod is 0, 1, or 2 depending on if the user wants
	 *  to calculate the distance, field strength, or maximum ERP.
	 * 
	 * Using computationMethod 0 calls getDistance and the API should work as
	 *  originally built. New functionality added in to call getFieldStrength
	 *  and getMaxPower when computation method is 1 or 2 respectively.
	 */
	try {
		var haat = req.query.haat;
		var field = req.query.field;
		var erp = req.query.erp;
		var distance = req.query.distance;
		var channel = req.query.channel;
		var curve = req.query.curve;
		var serviceType = req.query.serviceType;
		var computationMethod = req.query.computationMethod;

		var dataObj = new Object;
		dataObj['status'] = 'error';
		dataObj['statusCode'] = '400';
		dataObj['statusMessage'] = '';

		// *** REQUIRED FIELD CHECKS *** //
		// *** SERVICE TYPE CHECKS *** //
		if (serviceType == undefined) {
			console.log('Missing serviceType');
			dataObj.statusMessage = 'Missing serviceType parameter.';
			return callback(dataObj);
		}

		serviceType = serviceType.toLowerCase();

		// *** COMPUTATION METHOD CHECKS *** //
		// Valid values:
		// 0: distance (default)
		// 1: field strength
		// 2: max ERP
		if (computationMethod == undefined) {
			computationMethod = '0';
			console.log('Computation method not provided. Forcing 0 (distance) for backward compatibility.');
		}

		if (!computationMethod.match(/^\d+$/)) {
			console.log('invalid computationMethod value');
			dataObj.statusMessage = 'Invalid computationMethod value.';
			return callback(dataObj);
		}

		computationMethod = parseFloat(computationMethod);

		if (computationMethod < 0 || computationMethod > 2) {
			console.log('Computation method value out of range [0, 2]');
			dataObj.statusMessage = 'Computation method value out of range [0, 2].';
			return callback(dataObj);
		}

		var tv_fm_list = ['tv', 'fm'];
		if (tv_fm_list.indexOf(serviceType) < 0) {
			console.log('invalid serviceType value');
			dataObj.statusMessage = 'Invalid serviceType value.';
			return callback(dataObj);
		}

		// *** HAAT CHECKS *** //
		if (haat == undefined) {
			console.log('Missing haat');
			dataObj.statusMessage = 'Missing haat.';
			return callback(dataObj);
		}

		// ** Ahmad Aburizaiza **
		// the regexp fixed to include negative numbers
		if (!haat.match(/^-?\d+\.?\d*$/)) {
			console.log('invalid haat value');
			dataObj.statusMessage = 'Invalid haat value.';
			return callback(dataObj);
		}

		if (parseFloat(haat) > 1600.0){
			console.log('HAAT value out of range ( > 1600)');
			dataObj.statusMessage = 'HAAT value cannot exceed 1600.';
			return callback(dataObj);
		}

		// *** CHANNEL CHECKS *** //
		if (channel == undefined) {
			if (serviceType == 'tv') {
				console.log('Missing channel');
				dataObj.statusMessage = 'Missing channel.';
				return callback(dataObj);
			} else if ((serviceType == 'fm') && ((computationMethod == 0) || (computationMethod == 1))) {
				channel = '6';
			} else {
				channel = '250';
			}
		}

		if (channel && !channel.match(/\d+$/)) {
			console.log('invalid channel value');
			dataObj.statusMessage = 'Invalid channel value.';
			return callback(dataObj);
		}

		/*
		if(serviceType === 'fm' && (channel !== '6' || channel == undefined)){
			console.log('Channel 6 is the only valid channel for FM services');
			dataObj.statusMessage = 'Only channel 6 allowed for FM services';
			return callback(dataObj);
		}
		*/
		
		// *** CURVE CHECKS *** //
		// Valid values:
		// 0: F(50,50)
		// 1: F(50,10)
		// 2: F(50,90)
		if (curve == undefined) {
			console.log('Missing curve');
			dataObj.statusMessage = 'Missing curve.';
			return callback(dataObj);
		}

		if (!curve.match(/^\d+$/)) {
			console.log('invalid curve value');
			dataObj.statusMessage = 'Invalid curve value.';
			return callback(dataObj);
		}

		if (parseFloat(curve) < 0 || parseFloat(curve) > 2) {
			console.log('Curve value out of range [0, 2]');
			dataObj.statusMessage = 'Curve value out of range [0, 2].';
			return callback(dataObj);
		}

		haat = parseFloat(haat);
		channel = parseFloat(channel);
		curve = parseFloat(curve);

		// ** Ahmad Aburizaiza **
		// update the value of haat to 30 if it is less than 30
		// the value is updated in tvfmfs_metric(..) but not returned
		// for the post code that requires the updated haat value
		if(parseFloat(haat) < 30.0){
			haat = 30.0;
		}

		// *** END REQUIRED FIELD CHECKS *** //

		// Determine which optional fields are needed based on the computation method
		// CM 0 (Distance) - Requires field strength and ERP
		// CM 1 (Field Strength) - Requires distance and ERP
		// CM 2 (ERP) - Requires distance and field strength
		var result = -1;

		if (computationMethod == 0) {
			if (field == undefined) {
				console.log('Mssing field strength.');
				dataObj.statusMessage = 'Missing field';
				return callback(dataObj);
			}

			if (erp == undefined) {
				console.log('Mssing erp.');
				dataObj.statusMessage = 'Missing erp';
				return callback(dataObj);
			}

			if (!field.match(/^-?\d+\.?\d*$/)) {
				console.log('Invalid field strength value.')
				dataObj.statusMessage = 'Invalid field value';
				return callback(dataObj);
			}

			if (!erp.match(/^\d+\.?\d*$/)) {
				console.log('Invalid erp value.')
				dataObj.statusMessage = 'Invalid erp value';
				return callback(dataObj);
			}

			field = parseFloat(field);
			erp = parseFloat(erp);

			result = getDistance(haat, serviceType, channel, curve, field, erp);
		} else if (computationMethod == 1) {
			if (distance == undefined) {
				console.log('Mssing distance.');
				dataObj.statusMessage = 'Missing distance';
				return callback(dataObj);
			}

			if (erp == undefined) {
				console.log('Mssing erp.');
				dataObj.statusMessage = 'Missing erp';
				return callback(dataObj);
			}

			if (!distance.match(/^-?\d+\.?\d*$/)) {
				console.log('Invalid distance value.')
				dataObj.statusMessage = 'Invalid distance value';
				return callback(dataObj);
			}

			if (!erp.match(/^\d+\.?\d*$/)) {
				console.log('Invalid erp value.')
				dataObj.statusMessage = 'Invalid erp value';
				return callback(dataObj);
			}

			distance = parseFloat(distance);
			erp = parseFloat(erp);

			result = getFieldStrength(haat, serviceType, channel, curve, erp, distance);
		} else if (computationMethod == 2) {
			if (distance == undefined) {
				console.log('Mssing distance.');
				dataObj.statusMessage = 'Missing distance';
				return callback(dataObj);
			}

			if (field == undefined) {
				console.log('Mssing field strength.');
				dataObj.statusMessage = 'Missing field';
				return callback(dataObj);
			}

			if (!distance.match(/^-?\d+\.?\d*$/)) {
				console.log('Invalid distance value.')
				dataObj.statusMessage = 'Invalid distance value';
				return callback(dataObj);
			}

			if (!field.match(/^-?\d+\.?\d*$/)) {
				console.log('Invalid field strength value.')
				dataObj.statusMessage = 'Invalid field value';
				return callback(dataObj);
			}

			distance = parseFloat(distance);
			field = parseFloat(field);
			result = getMaxPower(haat, serviceType, channel, curve, field, distance);
		}

		console.log('computationMethod='+computationMethod);
		console.log('result=');
		console.log(result);

		if(isNaN(result)) {
			var comments = "";
			for (var i = 0; i < result.length; i++) {
				if (result[i] == 1) {
					if(i === 12 && serviceType.toLowerCase() == 'fm'){
						console.log('comment for item=18')					
						var comment = tvfmfs_comment(18).replace(/^.*;/, '').replace(/\..*\n/, '');
						comments += comment + ";";
					}else{
						console.log('comment for item='+i)					
						var comment = tvfmfs_comment(i).replace(/^.*;/, '').replace(/\..*\n/, '');
						comments += comment + ";";
					}
				}
			}
			
			comments = comments.replace(/;$/, '');
			dataObj.statusMessage = comments;
			return callback(dataObj);
		} else if (result < 0) {
			dataObj.statusMessage = 'CURVES error occurred when calculating computation method'
			return callback(dataObj);
		} else {
			dataObj.status = 'success';
			dataObj.statusCode = '200';
			dataObj.statusMessage = 'ok';
			dataObj.haat = haat;
			dataObj.haat_unit = 'm';
			dataObj.channel = channel;
			dataObj.curve = curve;
			dataObj.serviceType = serviceType;
			dataObj.computationMethod = computationMethod;
			if (computationMethod == 0) {
				dataObj.computedField = "distance";
				dataObj.distance = mathjs.round(result, 3);
				dataObj.field = mathjs.round(field, 1);
				dataObj.erp = mathjs.round(erp, 3);
			} else if (computationMethod == 1) {
				dataObj.computedField = "field";
				dataObj.distance = mathjs.round(distance, 3);
				dataObj.field = mathjs.round(result, 1);
				dataObj.erp = mathjs.round(erp, 3);
			} else if (computationMethod == 2) {
				dataObj.computedField = "erp";
				dataObj.distance = mathjs.round(distance,3);
				dataObj.field = mathjs.round(field, 1);
				dataObj.erp = mathjs.round(result, 3);
			}
			dataObj.distance_unit = 'km';
			dataObj.field_unit = 'dbu';
			dataObj.erp_unit = 'kw';

			return callback(dataObj);
		}


	}
	catch(err) {
		console.log('err='+err);
		dataObj.error = err.stack;
		dataObj.statusMessage = 'CURVES error occurred.';
		return callback(dataObj);
	}
}

function getFieldStrength(haat, serviceType, channel, curve, erp, distance) {
	console.log('================ Start CURVES Field Strength API ===================');
	var fs_or_dist = 1;
	var flag = [];
	var field = 0;
	var field = tvfmfs_metric(erp, haat, channel, field, distance, fs_or_dist, curve, flag);
	return field;
}

function getMaxPower(haat, serviceType, channel, curve, field, distance) {
	console.log('================ Start CURVES Max ERP API ===================');
	var fs_or_dist = 3;
	var flag = [];
	var erp = 0;
	var erp = tvfmfs_metric(erp, haat, channel, field, distance, fs_or_dist, curve, flag);
	return erp;
}

function getDistance(haat, serviceType, channel, curve, field, erp) {
	console.log('================ Start CURVES Distance API ===================');
	var fs_or_dist = 2;
	var flag = [];
	var distance = 0;
	var distance = tvfmfs_metric(erp, haat, channel, field, distance, fs_or_dist, curve, flag);
	return distance;
}

module.exports.tvfmfs_metric = tvfmfs_metric;
module.exports.getResult = getResult;



