// **********************************************************

'use strict';

// **********************************************************

var mathjs = require('mathjs');

// To avoid ReferenceError: function not defined, these anonymous functions need
// to be declared OUTSIDE the $(document).ready function

//---- FM and TV Propagation Curves Data ---------------------------------------------------------------

// Distance values for F(50,50) curves
var D50 = [1.609344, 3.218688, 4.828032, 6.437376, 8.046720, 16.09344, 32.18688, 48.28032, 64.37376, 80.46720, 96.56064, 112.65408, 128.74752, 144.84096, 160.93440, 177.02784, 193.12128, 209.21472, 225.30816, 241.40160, 257.49504, 273.58848, 289.68192, 305.77536, 321.86880, 0.0];

// Distance values for F(50,10) curves
// Distance of D10(31) added to smooth out the graph and interpolation
// for the F(50,10) curve at the rarely used distance of (almost) 500 km

var D10 = [16.09344, 32.18688, 48.28032, 64.37376, 80.46720, 96.56064, 112.65408, 128.74752, 144.84096, 160.93440, 177.02784, 193.12128, 209.21472, 225.30816, 241.40160, 257.49504, 273.58848, 289.68192, 305.77536, 321.86880, 337.96224, 354.05568, 370.14912, 386.24256, 402.33600, 418.42944, 434.52288, 450.61632, 466.70976, 482.80320, 498.89644, 0.0];

// Height values H10, H50 in meters
var H50 = [30.48, 60.96, 121.92, 182.88, 243.84, 304.80, 381.00, 457.20, 533.40, 609.60, 914.40, 1219.20, 1524.00, 0.0];

var H10 = [30.48, 60.96, 121.92, 182.88, 243.84, 304.80, 381.00, 457.20, 533.40, 609.60, 914.40, 1219.20, 1524.00, 0.0];


/************************************************************************
 !  F(50,50) FIELD STRENGTH DATA FOR THE LOW VHF PROPAGATION CURVE.  (FM AND TV CHANNELS 2 THROUGH 6 )  --  (13 points * 25 curves = 325)                        *
 !***********************************************************************/
// was [25][13]

var F55LV = [92., 79.7, 72.7, 67.8,
    64., 52., 39.4, 31., 25.3, 20.3, 16.2, 12.8, 9.8, 6.9, 4., 1.5,
    -1.1, -3.6, -5.8, -8.1, -10.6, -13., -15.1, -17.2, -19.2, 98.,
    85.9, 79., 73.8, 70., 58., 45.5, 37., 29.5, 23.5, 18.1, 14.5,
    11., 8.2, 5.5, 2.9, .3, -2.2, -4.8, -7., -9.4, -11.7, -14.,
    -16.1, -18.3, 100.6, 91., 84.8, 80., 76., 64., 51.5, 43., 35.5,
    28.8, 22., 17.1, 13.4, 10.2, 7.4, 4.8, 2.2, -.3, -3., -5.2, -7.6,
    -10., -12.2, -14.6, -16.9, 101.5, 93.4, 87.8, 83.3, 79.6, 67.6,
    55., 46.7, 39., 32., 25.3, 19.8, 15.2, 11.8, 8.9, 6., 3.7, 1.,
    -1.4, -3.9, -6.1, -8.7, -11., -13.2, -15.6, 101.9, 94.6, 89.4,
    85.4, 82., 70., 57.6, 49., 41.5, 34.4, 27.7, 22., 17., 13.1,
    10.1, 7.2, 4.8, 2., -.3, -2.7, -5.1, -7.6, -10., -12.1, -14.6,
    102., 95., 90.4, 86.8, 83.7, 72., 59.6, 51., 43.6, 36.7, 29.9,
    23.9, 18.8, 14.7, 11.5, 8.4, 5.7, 3., .6, -1.8, -4.2, -6.6, -9.,
    -11.2, -13.6, 102.1, 95.6, 91.2, 87.7, 85., 73.9, 61.7, 53.2,
    45.9, 39.1, 32., 26., 21., 16.8, 13.1, 9.9, 7., 4.1, 1.7, -.7,
    -3.2, -5.6, -8., -10.2, -12.5, 102.2, 95.9, 91.8, 88.3, 85.8,
    75.4, 63.3, 55.1, 47.9, 41.5, 34.4, 28.3, 23.2, 18.8, 14.9, 11.1,
    8., 5.2, 2.7, .2, -2.2, -4.6, -7., -9.2, -11.6, 102.3, 96., 92.,
    88.9, 86.3, 76.7, 64.9, 57., 50., 43.5, 36.7, 30.7, 25.2, 20.4,
    16., 12.5, 9.1, 6.2, 3.8, 1.1, -1.3, -3.6, -6.1, -8.4, -10.6,
    102.4, 96.1, 92.2, 89.2, 86.7, 77.9, 66.2, 58.5, 51.5, 45., 38.2,
    32.4, 27., 22., 17.3, 13.7, 10.1, 7.1, 4.6, 2., -.4, -2.7, -5.1,
    -7.6, -10., 102.5, 96.3, 92.5, 89.9, 87.6, 80.2, 70., 62.6, 55.4,
    48.9, 42.5, 36.9, 31., 25.7, 21., 17.1, 13.6, 10.3, 7.8, 5.1,
    2.8, .5, -2.1, -4.5, -6.8, 102.5, 96.5, 92.5, 90.1, 88., 81.3,
    72.4, 65., 57.8, 51.2, 44.9, 39.1, 33.2, 28.1, 23.5, 19.8, 16.1,
    13., 10.4, 8., 5.5, 3.1, .6, -2., -4.1, 102.5, 96.5, 92.5, 90.2,
    88.1, 81.9, 74.2, 66.5, 59.6, 53., 46.4, 40.8, 35., 30., 25.5,
    21.8, 18.3, 15., 12.4, 10., 7.7, 5.1, 2.8, .2, -2.];


/***********************************************************************
 !  F(50,10)  FIELD STRENGTH DATA  FOR THE LOW VHF PROPAGATION CURVE.  ( FM AND TV CHANNELS 2 THROUGH 6 ) -- (13 points * 31 curves = 403)
 !**********************************************************************/
// Includes a derived Interfering curve (31) to smooth out the graph and interpolation for the rarely used F(50,10) curve at 498.89644 km
// was [31][13]

var F51LV = [52.2, 41.4, 36.4, 33.,
    30., 26.7, 23.5, 20.4, 17.4, 14.5, 11.5, 8.5, 5.9, 3., .6, -2.,
    -4.3, -6.6, -8.7, -10.5, -12.5, -14.6, -16.6, -18.6, -20.5,
    -22.4, -24.3, -26.2, -28.1, -30., -31.9, 58.4, 47., 40.9, 36.,
    31.9, 28., 24.9, 22., 19., 16.1, 13.1, 10.1, 7.7, 4.9, 2., -.4,
    -3., -5.1, -7.4, -9.4, -11.4, -13.4, -15.5, -17.4, -19.3, -21.2,
    -23.2, -25., -27., -29., -31., 64.3, 53., 45.9, 39.9, 35., 30.5,
    26.9, 24., 20.9, 18.2, 15.3, 12.4, 9.8, 6.9, 4.1, 1.6, -1., -3.4,
    -5.8, -8., -10.1, -12., -14.1, -16., -18., -19.9, -21.9, -23.7,
    -25.6, -27.4, -29.2, 68., 56.5, 49., 43., 37.7, 32.8, 28.8, 25.6,
    22.5, 19.8, 16.9, 13.9, 11., 8.2, 5.7, 2.9, .3, -2.2, -4.6, -6.9,
    -9., -11., -13., -15., -17., -18.9, -20.9, -22.5, -24.6, -26.3,
    -28., 70.5, 59., 51.7, 45.4, 40., 34.9, 30.4, 27., 23.9, 21.,
    18.2, 15.1, 12.3, 9.7, 6.9, 4.1, 1.6, -1., -3.4, -5.7, -8., -10.,
    -12., -14., -16., -17.9, -19.9, -21.7, -23.6, -25.4, -27.2, 72.3,
    60.9, 53.7, 47.5, 41.9, 36.8, 32., 28.4, 25., 22., 19.2, 16.2,
    13.4, 10.7, 8., 5.3, 2.7, 0., -2.5, -4.9, -7., -9., -11.2, -13.2,
    -15.1, -17., -19., -21., -23., -24.6, -26.2, 74.2, 63., 56., 50.,
    44.4, 39.2, 34.9, 30.8, 27., 23.9, 20.8, 17.8, 14.8, 12., 9.1,
    6.7, 3.9, 1.1, -1.4, -3.9, -6., -8., -10.2, -12.2, -14.2, -16.2,
    -18.1, -20., -22., -23.7, -25.4, 75.9, 64.8, 57.9, 52., 46.7,
    41.6, 37.1, 33., 29., 25.5, 22., 19., 16., 13.2, 10.3, 7.9, 5.,
    2.2, -.2, -2.8, -5., -7., -9.2, -11.3, -13.3, -15.3, -17.2,
    -19.2, -21.1, -22.8, -24.5, 77., 66.2, 59.6, 54., 48.5, 43.5,
    39.2, 35., 30.8, 26.9, 23.2, 20., 17.1, 14.2, 11.6, 9., 6., 3.3,
    .9, -1.8, -4., -6.2, -8.2, -10.5, -12.5, -14.6, -16.3, -18.4,
    -20.2, -22., -23.8, 78.2, 67.6, 60.9, 55.2, 50., 45., 40.7, 36.2,
    32., 28., 24.1, 21., 18., 15.3, 12.5, 10., 7., 4.4, 1.8, -.8,
    -3., -5.3, -7.4, -9.8, -11.8, -14., -15.8, -17.8, -19.6, -21.3,
    -23., 80.8, 71.2, 64.5, 58.9, 53.9, 49., 44.2, 39.8, 35.4, 31.3,
    27.6, 24.4, 21.6, 18.9, 16., 13.6, 10.7, 8., 5.2, 2.8, .3, -2.,
    -4.5, -7., -9., -11.1, -13.2, -15., -17., -19., -21., 81.8, 73.8,
    67., 61.4, 56.3, 51.7, 46.9, 42., 37.8, 33.8, 30., 27., 24.1,
    21.5, 18.8, 16.1, 13.6, 10.9, 8.1, 5.3, 3., .4, -1.9, -4.3, -6.7,
    -9., -11., -12.9, -14.9, -16.9, -18.9, 82.2, 75.5, 69., 63.3,
    58.4, 53.5, 48.8, 44., 39.7, 35.7, 32.1, 29.1, 26.1, 23.5, 20.9,
    18., 15.7, 13., 10.2, 7.5, 5., 2.6, 0., -2.4, -4.6, -6.9, -9.,
    -11., -13., -15., -17.];


/***********************************************************************
 !  F(50,50) FIELD STRENGTH DATA FOR THE HIGH VHF PROPAGATION CURVE  ( TV CHANNELS 7 THROUGH 13 ) -- (13 points * 25 rows = 325)
 !*********************************************************************/
// was [25][13]


var F55HV = [94.6, 82.8, 75.7,
    70.7, 66.8, 55., 42.5, 34., 26.3, 20.7, 16.3, 12.9, 9.9, 7., 4.3,
    1.5, -1., -3.5, -5.7, -8., -10.4, -12.8, -15., -17.2, -19.1,
    100.7, 88.9, 81.8, 76.9, 73., 61., 48.6, 40., 32., 24.1, 18.5,
    14.4, 11.2, 8.3, 5.5, 2.9, .5, -2., -4.3, -6.9, -9.2, -11.5,
    -13.8, -16., -18.2, 101.6, 92.3, 86.6, 82.2, 78.8, 67.2, 54.7,
    46.1, 38.1, 30.1, 23., 17., 13.5, 10.5, 7.5, 4.8, 2.3, -.3, -2.7,
    -5., -7.3, -9.8, -12., -14.4, -16.8, 101.8, 93.9, 88.7, 84.8,
    81.6, 70.8, 58.1, 49.8, 41.7, 33.8, 26.2, 20., 15.2, 12., 9.,
    6.2, 3.7, 1., -1.2, -3.7, -6., -8.4, -10.7, -13., -15.5, 101.9,
    94.6, 89.8, 86.2, 83.2, 73.2, 60.7, 52.1, 44., 36.1, 28.8, 22.1,
    17., 13.7, 10.4, 7.5, 4.8, 2.2, -.1, -2.5, -4.9, -7.3, -9.7,
    -12., -14.4, 102., 95., 90.5, 87., 84.5, 75., 62.5, 54.2, 46.,
    38., 30.6, 24., 18.9, 15., 11.5, 8.6, 5.8, 3.2, .9, -1.5, -4.,
    -6.3, -8.7, -11., -13.4, 102.3, 95.4, 91.3, 88., 85.7, 77., 65.,
    56.7, 48.8, 40.9, 33.5, 26.8, 21.2, 17., 13.1, 10., 7., 4.4, 2.,
    -.5, -3., -5.3, -7.6, -10., -12.3, 102.3, 95.7, 91.8, 88.7, 86.3,
    78.1, 67.6, 59., 51., 43.5, 36.3, 29.6, 23.9, 19., 14.9, 11.2,
    8.2, 5.5, 3., .6, -2., -4.3, -6.6, -9., -11.3, 102.3, 95.9, 92.,
    89.1, 87., 79.1, 69.5, 61., 53.3, 46., 39., 32., 26., 21., 16.2,
    12.7, 9.5, 6.5, 4., 1.5, -1., -3.5, -5.8, -8.2, -10.5, 102.4,
    96., 92.1, 89.5, 87.3, 80., 71., 62.8, 55., 47.9, 41., 34., 28.,
    22.6, 17.5, 13.6, 10.5, 7.4, 4.9, 2.2, -.2, -2.6, -5., -7.3,
    -9.8, 102.4, 96.2, 92.6, 90., 88., 81.1, 73.9, 66.3, 58.7, 52.,
    45., 38.2, 32., 26.3, 21.1, 17., 14., 10.7, 8., 5.6, 3., .6,
    -1.8, -4.2, -6.6, 102.4, 96.2, 92.6, 90., 88., 81.8, 74.8, 67.4,
    60.3, 53.8, 47., 40.6, 34.4, 28.8, 23.8, 19.8, 16.6, 13.1, 10.4,
    8.2, 5.5, 3.1, .9, -1.8, -4., 102.5, 96.5, 92.7, 90.1, 88., 82.,
    75., 68., 61.1, 54.6, 48.1, 42., 36.1, 30.6, 25.5, 21.8, 18.5,
    15.1, 12.3, 10.1, 7.5, 5.1, 2.9, .3, -1.9];


/***********************************************************************
 !   F(50,10) FIELD STRENGTH DATA FOR THE HIGH VHF PROPAGATION CURVE  ( TV CHANNELS 7 THROUGH 13 ) -- (13 points * 31 curves = 403)
 !***********************************************************************/
// Includes a derived Interfering curve (31) to smooth out the graph and interpolation for the rarely used F(50,10) curve at 498.89644 km
// was [31][13]

var F51HV = [55.4, 44.4, 39.2, 34.,
    29.9, 26.6, 23.5, 20.3, 17.4, 14.3, 11.3, 8.6, 5.8, 2.9, .3,
    -2.1, -4.4, -6.7, -8.9, -10.8, -12.9, -14.8, -16.9, -18.8, -20.7,
    -22.7, -24.6, -26.4, -28.2, -30.1, -32., 61.6, 50., 43.5, 38.,
    32.5, 28.2, 25., 22., 19., 16., 13., 10., 7.2, 4.7, 1.9, -.7,
    -3.2, -5.4, -7.8, -9.8, -11.8, -13.8, -15.8, -17.7, -19.7, -21.4,
    -23.3, -25.2, -27.1, -29., -30.9, 67.7, 55.8, 48.6, 42.7, 35.9,
    31., 27., 24., 21., 18.1, 15.1, 12.2, 9.4, 6.8, 3.8, 1.2, -1.4,
    -3.8, -6.1, -8.2, -10.3, -12.3, -14.3, -16.3, -18.3, -20.1, -22.,
    -24., -25.9, -27.7, -29.5, 71., 59.1, 52., 45.6, 38.8, 33.4,
    28.9, 25.5, 22.4, 19.6, 16.7, 13.7, 10.8, 8.1, 5.2, 2.7, 0.,
    -2.3, -4.8, -7., -9., -11.1, -13.1, -15.1, -17., -19., -20.9,
    -22.9, -24.8, -26.5, -28.2, 73.5, 61.7, 54.6, 48., 41., 35.4,
    30.7, 27., 23.8, 20.8, 18., 15., 12., 9.5, 6.5, 3.9, 1.2, -1.2,
    -3.8, -6., -8.2, -10.2, -12.2, -14.2, -16.2, -18., -20., -21.9,
    -23.9, -25.5, -27.1, 75.3, 63.7, 56.5, 50., 43., 37.4, 32.3,
    28.3, 25., 22., 19.1, 16.3, 13.3, 10.6, 7.8, 5., 2.4, 0., -2.6,
    -5., -7.1, -9.3, -11.2, -13.3, -15.3, -17.2, -19.1, -21., -23.,
    -24.9, -26.7, 77.1, 66.5, 59., 52.5, 45.8, 40., 35., 30.4, 26.9,
    23.5, 20.5, 17.6, 14.7, 12., 9., 6.4, 3.7, 1., -1.4, -4., -6.,
    -8.2, -10.2, -12.3, -14.3, -16.2, -18.2, -20., -22., -23.9,
    -25.8, 78.6, 68.9, 61.5, 54.9, 48.2, 43., 37.4, 32.9, 28.8, 25.,
    22., 18.8, 15.9, 13., 10.3, 7.5, 4.9, 2.1, -.3, -3., -5.1, -7.4,
    -9.4, -11.4, -13.5, -15.4, -17.4, -19.2, -21.1, -23., -24.9,
    79.6, 70.8, 63.6, 56.9, 50.8, 45.4, 40., 35., 30.4, 26.4, 23.,
    19.9, 17., 14.1, 11.5, 8.8, 6., 3.3, .8, -2., -4.2, -6.5, -8.6,
    -10.6, -12.8, -14.8, -16.8, -18.5, -20.3, -22.1, -23.9, 80.4,
    72., 65.2, 58.8, 53., 47.6, 42., 36.8, 32., 27.7, 24., 20.7, 18.,
    15.2, 12.5, 9.8, 7., 4.3, 1.7, -1., -3.3, -5.6, -7.8, -9.8, -12.,
    -14., -16., -18., -19.6, -21.5, -23.4, 82., 75., 68.6, 62.5, 57.,
    52., 46.8, 41.5, 35.8, 31., 27.6, 24., 21.4, 18.8, 16., 13.1,
    10.6, 7.9, 5., 2.5, 0., -2.4, -4.7, -6.9, -9., -11.1, -13.1,
    -15.1, -17., -19., -21., 82.4, 75.9, 69.8, 64., 58.9, 53.8, 48.9,
    43.7, 38.2, 33.6, 30., 26.8, 24., 21.2, 18.7, 15.9, 13.2, 10.6,
    8., 5.2, 2.8, .2, -2., -4.3, -6.5, -9., -11., -13., -15., -16.8,
    -18.6, 82.5, 76.2, 70.2, 64.9, 59.8, 54.8, 50., 45., 40.1, 35.5,
    32., 28.9, 26., 23.4, 20.7, 18., 15.4, 12.8, 10., 7.3, 4.9, 2.2,
    -.1, -2.4, -4.7, -7., -9., -11., -13., -15., -17.];

/***********************************************************************
 !   F(50,50) FIELD STRENGTH DATA FOR THE UHF PROPAGATION CURVE ( TV CHANNELS 14 THROUGH 83 ) -- (13 points * 25 curves = 325)
 !***********************************************************************/
// was [25][13]

var F55U = [92., 80., 72.9, 67.9,
    63.8, 51.9, 39., 27.5, 17.8, 13., 10.1, 7., 4.2, 1.6, -1., -3.2,
    -5., -7.2, -9.1, -11., -13.1, -15.1, -17.2, -19.3, -21.4, 97.9,
    86., 79., 74., 70., 58., 45.2, 33.5, 22.7, 16., 11.7, 8.5, 5.5,
    2.8, .2, -2., -4.2, -6.3, -8.4, -10.3, -12.3, -14.2, -16.2,
    -18.3, -20.1, 100.7, 91., 84.7, 80., 76., 64., 51.2, 39.6, 28.2,
    19.6, 14.4, 10.8, 7.7, 4.7, 1.9, -.4, -2.7, -4.9, -7., -8.9,
    -10.9, -12.8, -14.8, -16.8, -18.7, 101.5, 93., 87.4, 83.3, 79.5,
    67.6, 54.6, 43., 31.5, 22.3, 16.8, 12.5, 9.3, 6., 3.2, .7, -1.5,
    -3.8, -5.9, -7.9, -9.9, -11.7, -13.8, -15.8, -17.7, 101.9, 94.1,
    89., 85.1, 81.5, 70., 57.2, 45.7, 34.5, 25.1, 19.1, 14.2, 10.8,
    7.5, 4.6, 1.9, -.4, -2.9, -5., -7., -9., -10.8, -12.8, -14.8,
    -16.8, 102., 94.8, 90., 86.3, 82.9, 72., 59.1, 48., 37.3, 28.3,
    21.7, 16.3, 12.4, 8.9, 5.7, 3., .5, -2., -4.2, -6.1, -8., -10.,
    -11.9, -13.9, -15.9, 102.1, 95.2, 90.8, 87.3, 84.1, 73.8, 61.,
    50.5, 40.3, 31.8, 24.7, 19., 14.5, 10.6, 7.1, 4.3, 1.7, -.9,
    -3.2, -5.2, -7.1, -9., -11., -13., -15., 102.2, 95.6, 91.3, 88.,
    85., 75.3, 62.6, 52.3, 42.7, 34.1, 27., 21.3, 16.3, 12., 8.5,
    5.6, 2.8, 0., -2.3, -4.3, -6.2, -8.2, -10.2, -12.2, -14.1, 102.3,
    95.9, 91.8, 88.6, 85.8, 76.5, 64., 53.9, 44.3, 36., 29.3, 23.4,
    18., 13.6, 9.7, 6.7, 3.8, 1., -1.6, -3.6, -5.5, -7.5, -9.5,
    -11.4, -13.2, 102.4, 96., 92., 88.9, 86.2, 77.2, 65., 55., 45.7,
    37.6, 31., 25., 19.8, 15., 10.8, 7.7, 4.8, 1.9, -.9, -3., -4.8,
    -6.8, -8.9, -10.8, -12.5, 102.5, 96.3, 92.5, 89.6, 87.3, 79.6,
    68.2, 58.4, 49.4, 41.7, 35.4, 29.8, 24.5, 19.8, 15., 11.5, 8.2,
    5., 2., -.2, -2.2, -4.3, -6.3, -8.3, -10., 102.5, 96.5, 92.8,
    90., 87.9, 80.5, 70., 60.8, 52.1, 44.8, 38.6, 33., 28., 23.4,
    18.8, 14.8, 11.1, 7.8, 4.6, 1.9, -.1, -2.2, -4.2, -6.1, -8.,
    102.5, 96.5, 93., 90.3, 88.1, 81., 71.1, 62.5, 54., 46.7, 41.,
    35.7, 30.8, 26., 21.8, 17.5, 13.7, 10., 6.7, 3.7, 1.7, -.4, -2.3,
    -4.4, -6.3];

/***********************************************************************
 !   F(50,10) FIELD STRENGTH DATA FOR THE UHF PROPAGATION CURVE ( TV CHANNELS 14 THROUGH 83 )  - (13 points * 31 curves = 403)
 !***********************************************************************/
// Includes a derived Interfering curve (31) to smooth out the graph and interpolation for the rarely used F(50,10) curve at 498.89644 km
// was [31][13]

var F51U = [52.2, 41.6, 35., 30.3,
    27., 23.8, 20.8, 17.8, 14.8, 12., 9.2, 6.6, 4., 1.2, -1.3, -3.8,
    -6., -8.4, -10.3, -12.5, -14.5, -16.5, -18.5, -20.5, -22.4,
    -24.2, -26., -27.8, -29.5, -31., -32.5, 58.3, 46.7, 38., 32.1,
    28.3, 25.2, 22.2, 19.3, 16.5, 13.4, 10.7, 8., 5.1, 2.5, -.2,
    -2.4, -4.9, -7.2, -9.3, -11.3, -13.5, -15.5, -17.4, -19.3, -21.3,
    -23.2, -25., -27., -28.5, -30.1, -31.6, 64.7, 52.4, 43., 35.3,
    30.8, 27.6, 24.5, 21.3, 18.5, 15.6, 12.7, 9.9, 7.1, 4.4, 1.8,
    -.8, -3.1, -5.5, -7.7, -9.8, -12., -14., -15.9, -17.8, -19.8,
    -21.6, -23.4, -25.5, -27.1, -28.9, -30.7, 68., 56., 46.3, 37.6,
    32.6, 29.1, 26., 23., 20., 17.1, 14., 11.2, 8.8, 6., 3.2, .8,
    -1.7, -4.1, -6.2, -8.4, -10.4, -12.7, -14.6, -16.5, -18.6, -20.4,
    -22.2, -24.2, -26., -27.9, -29.8, 70.5, 58.5, 48.8, 40., 34.7,
    30.4, 27.2, 24.2, 21.2, 18.3, 15.2, 12.6, 10., 7.3, 4.6, 1.9,
    -.5, -3., -5.2, -7.4, -9.6, -11.7, -13.8, -15.6, -17.7, -19.6,
    -21.3, -23.3, -25., -27., -29., 72.3, 60.3, 50.8, 42.4, 36.7,
    32., 28.4, 25.4, 22.4, 19.7, 16.5, 13.8, 11., 8.3, 5.7, 3., .6,
    -2., -4.3, -6.6, -8.8, -10.8, -13., -14.9, -17., -18.9, -20.8,
    -22.7, -24.4, -26.3, -28.2, 74.1, 62.3, 52.9, 45.1, 39., 34.5,
    30.4, 27., 23.9, 21., 18., 15.3, 12.5, 9.7, 7., 4.4, 1.8, -.7,
    -3.2, -5.4, -7.7, -9.8, -12., -14., -16., -17.9, -19.9, -21.8,
    -23.7, -25.6, -27.5, 75.4, 63.9, 54.9, 47.1, 40.8, 36.4, 32.2,
    28.8, 25.2, 22.1, 19.3, 16.4, 13.8, 10.9, 8.1, 5.6, 2.9, .3,
    -2.2, -4.5, -6.7, -8.9, -11., -13., -15., -17., -19.1, -21.,
    -22.8, -24.8, -26.8, 76.4, 65.2, 56.3, 48.7, 42.4, 37.9, 33.9,
    30.2, 26.6, 23.4, 20.3, 17.3, 14.8, 11.9, 9.1, 6.7, 3.9, 1.3,
    -1.2, -3.6, -5.8, -7.9, -10., -12.2, -14.2, -16.2, -18.2, -20.2,
    -22., -24., -26., 77.4, 66.2, 57.6, 50., 43.7, 39., 35.1, 31.7,
    27.8, 24.6, 21.3, 18.3, 15.7, 12.8, 10., 7.6, 4.8, 2.1, -.4,
    -2.8, -5., -7.1, -9.2, -11.3, -13.4, -15.4, -17.5, -19.4, -21.3,
    -23.2, -25.1, 79.5, 69.3, 60.9, 53.6, 47.7, 43.1, 39.2, 35.8,
    32., 28.3, 24.9, 21.7, 18.8, 15.9, 13.1, 10.6, 7.9, 5.1, 2.2, 0.,
    -2.2, -4.3, -6.6, -8.9, -11., -13., -15., -17., -19., -21.,
    -22.9, 80.7, 71.2, 63., 56.1, 50.2, 46., 42.1, 38.7, 35., 31.3,
    27.8, 24.3, 21.2, 18.2, 15.5, 12.8, 10., 7.3, 4.7, 2.1, 0., -2.2,
    -4.6, -6.8, -8.8, -10.8, -12.9, -14.9, -16.9, -18.9, -20.9, 81.3,
    72.6, 64.5, 58., 52.4, 48., 44.3, 40.7, 37.3, 33.8, 30.3, 27.,
    23.7, 20.5, 17.4, 14.7, 12., 9.2, 6.5, 4., 1.8, -.4, -2.8, -5.,
    -7., -9., -11., -13., -15., -16.8, -18.6];


/*  TVFMFS:  DATA TABLE INITIALIZATION OK, CONTINUE WITH PROGRAM   */

// ========The following data is needed for fzq to calculate F(50,90) or other curves ================//

var VGRID = [.01, .02, .03, .04, .05, .06, .07, .08, .09, .1, .15, .2, .3, .4, .5, .6, .7, .8, .9, 1., 1.2, 1.4, 1.6, 1.8, 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 22., 24., 26., 28., 30., 32., 34., 36., 38., 40., 42., 44., 46., 48., 50., 52., 54., 56., 58., 60., 62., 64., 66., 68., 70., 72., 74., 76., 78., 80., 81., 82., 83., 84., 85., 86., 87., 88., 89., 90., 91., 92., 93., 94., 95., 96., 97., 98., 98.2, 98.4, 98.6, 98.8, 99., 99.1, 99.2, 99.3, 99.4, 99.5, 99.6, 99.7, 99.8, 99.85, 99.9, 99.91, 99.92, 99.93, 99.94, 99.95, 99.96, 99.97, 99.98, 99.99];

var ZGRI = [-3.71902, -3.54008, -3.43161, -3.35279, -3.29053, -3.23888, -3.19465, -3.15591, -3.12139, -3.09023, -2.96774, -2.87816, -2.74778, -2.65207, -2.57583, -2.51214, -2.45726, -2.40892, -2.36562, -2.32635, -2.25713, -2.19729, -2.14441, -2.09693, -2.05375, -1.88079, -1.75069, -1.64485, -1.55477, -1.47579, -1.40507, -1.34076, -1.28155, -1.22653, -1.17499, -1.12639, -1.08032, -1.03643, -.99446, -.95416, -.91537, -.8779, -.84162, -.77219, -.7063, -.64335, -.58284, -.5244, -.4677, -.41246, -.35846, -.30548, -.25335, -.20189, -.15097, -.10043, -.05015];


/*
//------- ITPLBV --------------------------------------------------------------------------------------------------
// Interpolation subroutine, this is a bi-variate surface fitting procedure, refer to the original FCC CURVES program
// and to the paper referenced in comments above for details.  Sorry about the shortage of comments, but there were
// none in the original source.

// This has been modified from the original, taking into account the context in which it is being used.  It was a full
// general-purpose routine, however many of the conditions that had exception-handling could never have occurred given
// the limited range of possible values in context.  Much of that unnecessary code has been eliminated.

// Arguments:

//    lx  Number of columns in table.
//    ly  Number of rows in table.
//    x   Column enumeration values.
//    y   Row enumeration values.
//    z   Data table.
//    n   Number of points to lookup.
//    u   Column values for lookup points.
//    v   Row values for lookup points.
//    w   Return result of lookups.
*/


function itplbv(lx, ly, x, y, z, n, u, v, w) {

    // declarations and initializations


    var lxm1, lxp1, lym1, lyp1, ixpv, iypv, k, ix, iy, imn, imx, jx, jy, jx1, jy1;
    lxm1 = lxp1 = lym1 = lyp1 = ixpv = iypv = k = ix = iy = imn = imx = jx = jy = jx1 = jy1 = 0;

    var za_row0 = [0, 0];
    var za_row1 = [0, 0];
    var za_row2 = [0, 0];
    var za_row3 = [0, 0];
    var za_row4 = [0, 0];
    var za = [za_row0, za_row1, za_row2, za_row3, za_row4];   // za[5,2]

    var zb_row0 = [0, 0, 0, 0, 0];
    var zb_row1 = [0, 0, 0, 0, 0];
    var zb = [zb_row0, zb_row1];                              // zb[2,5]

    var zab_row0 = [0, 0, 0];
    var zab_row1 = [0, 0, 0];
    var zab_row2 = [0, 0, 0];
    var zab = [zab_row0, zab_row1, zab_row2];                  // zab[3,3]

    var zx_row0 = [0, 0, 0, 0];
    var zx_row1 = [0, 0, 0, 0];
    var zx_row2 = [0, 0, 0, 0];
    var zx_row3 = [0, 0, 0, 0];
    var zx = [zx_row0, zx_row1, zx_row2, zx_row3];            // zx[4,4]

    var zy_row0 = [0, 0, 0, 0];
    var zy_row1 = [0, 0, 0, 0];
    var zy_row2 = [0, 0, 0, 0];
    var zy_row3 = [0, 0, 0, 0];
    var zy = [zy_row0, zy_row1, zy_row2, zy_row3];            // zy[4,4]

    var zxy_row0 = [0, 0, 0, 0];
    var zxy_row1 = [0, 0, 0, 0];
    var zxy_row2 = [0, 0, 0, 0];
    var zxy_row3 = [0, 0, 0, 0];
    var zxy = [zxy_row0, zxy_row1, zxy_row2, zxy_row3];        // zy[4,4]


    var x3, x4, a3, y3, y4, b3, z33, z43, z34, z44, x2, a2, z23, z24, x5, a4, z53, z54;
    x3 = x4 = a3 = y3 = y4 = b3 = z33 = z43 = z34 = z44 = x2 = a2 = z23 = z24 = x5 = a4 = z53 = z54 = 0.0;

    var a1, a5, y2, b2, z32, z42, y5, b4, z35, z45, b1, b5, w2, w3, sw, wx2, wx3, wy2, wy3, w1, w4, w5;
    a1 = a5 = y2 = b2 = z32 = z42 = y5 = b4 = z35 = z45 = b1 = b5 = w2 = w3 = sw = wx2 = wx3 = wy2 = wy3 = w1 = w4 = w5 = 0.0;

    var zx3b3, zx4b3, zy3a3, zy4a3, a, b, c, d, e, a3sq, b3sq, p02, p03, p12, p13, p20, p21, p22;
    zx3b3 = zx4b3 = zy3a3 = zy4a3 = a = b = c = d = e = a3sq = b3sq = p02 = p03 = p12 = p13 = p20 = p21 = p22 = 0.0;

    var p23, p30, p31, p32, p33, dy, q0, q1, q2, q3, dx;
    p23 = p30 = p31 = p32 = p33 = dy = q0 = q1 = q2 = q3 = dx = 0.0;


    // Calculations begin


    lx = Math.floor(lx);
    ly = Math.floor(ly);


    lxm1 = Math.floor(lx - 1);
    lxp1 = Math.floor(lx + 1);
    lym1 = Math.floor(ly - 1);
    lyp1 = Math.floor(ly + 1);
    ixpv = -1;
    iypv = -1;
    for (k = 0; k < n; k++) {
        if (u[k] >= x[lxm1]) {
            ix = lx;
        } else {
            if (u[k] < x[0]) {
                ix = 0;
            } else {
                imn = 1;
                imx = lxm1;
                do {
                    ix = Math.floor((imn + imx) / 2);
                    if (u[k] >= x[ix]) {
                        imn = ix + 1;
                    } else {
                        imx = ix;
                    }
                } while (imx > imn);
                ix = imx;
            }
        }
        ix = Math.floor(ix);


        if (v[k] >= y[lym1]) {
            iy = ly;
        } else {
            if (v[k] < y[0]) {
                iy = 0;
            } else {
                imn = 1;
                imx = lym1;
                do {
                    iy = Math.floor((imn + imx) / 2);
                    if (v[k] >= y[iy]) {
                        imn = iy + 1;
                    } else {
                        imx = iy;
                    }
                } while (imx > imn);
                iy = imx;
            }
        }
        iy = Math.floor(iy);


        if ((ix != ixpv) || (iy != iypv)) {
            ixpv = ix;
            iypv = iy;
            if (ix == 0) {
                jx = 1;
            } else {
                if (ix == lx) {
                    jx = lxm1;
                } else {
                    jx = ix;
                }
            }
            if (iy == 0) {
                jy = 1;
            } else {
                if (iy == ly) {
                    jy = lym1;
                } else {
                    jy = iy;
                }
            }
            jx = Math.floor(jx);
            jy = Math.floor(jy);

            x3 = x[jx - 1];
            x4 = x[jx];
            a3 = 1. / (x4 - x3);
            y3 = y[jy - 1];
            y4 = y[jy];
            b3 = 1. / (y4 - y3);
            z33 = z[(jx - 1) + ((jy - 1) * lx)];
            z43 = z[jx + ((jy - 1) * lx)];
            z34 = z[(jx - 1) + (jy * lx)];
            z44 = z[jx + (jy * lx)];
            za[2][0] = (z43 - z33) * a3;
            za[2][1] = (z44 - z34) * a3;
            zb[0][2] = (z34 - z33) * b3;
            zb[1][2] = (z44 - z43) * b3;
            zab[1][1] = (zb[1][2] - zb[0][2]) * a3;
            if (jx > 1) {
                x2 = x[jx - 2];
                a2 = 1. / (x3 - x2);
                z23 = z[(jx - 2) + ((jy - 1) * lx)];
                z24 = z[(jx - 2) + (jy * lx)];
                za[1][0] = (z33 - z23) * a2;
                za[1][1] = (z34 - z24) * a2;
                if (jx == lxm1) {
                    za[3][0] = (2. * za[2][0]) - za[1][0];
                    za[3][1] = (2. * za[2][1]) - za[1][1];
                }
            }

            if (jx < lxm1) {
                x5 = x[jx + 1];
                a4 = 1. / (x5 - x4);
                z53 = z[(jx + 1) + ((jy - 1) * lx)];
                z54 = z[(jx + 1) + (jy * lx)];
                za[3][0] = (z53 - z43) * a4;
                za[3][1] = (z54 - z44) * a4;
                if (jx == 1) {
                    za[1][0] = (2. * za[2][0]) - za[3][0];
                    za[1][1] = (2. * za[2][1]) - za[3][1];
                }
            }

            zab[0][1] = (za[1][1] - za[1][0]) * b3;
            zab[2][1] = (za[3][1] - za[3][0]) * b3;
            if (jx > 2) {
                a1 = 1. / (x2 - x[jx - 3]);
                za[0][0] = (z23 - z[(jx - 3) + ((jy - 1) * lx)]) * a1;
                za[0][1] = (z24 - z[(jx - 3) + (jy * lx)]) * a1;
            } else {
                za[0][0] = (2. * za[1][0]) - za[2][0];
                za[0][1] = (2. * za[1][1]) - za[2][1];
            }
            if (jx < (lx - 2)) {
                a5 = 1. / (x[jx + 2] - x5);
                za[4][0] = (z[(jx + 2) + ((jy - 1) * lx)] - z53) * a5;
                za[4][1] = (z[(jx + 2) + (jy * lx)] - z54) * a5;
            } else {
                za[4][0] = (2. * za[3][0]) - za[2][0];
                za[4][1] = (2. * za[3][1]) - za[2][1];
            }
            if (jy > 1) {
                y2 = y[jy - 2];
                b2 = 1. / (y3 - y2);
                z32 = z[(jx - 1) + ((jy - 2) * lx)];
                z42 = z[jx + ((jy - 2) * lx)];
                zb[0][1] = (z33 - z32) * b2;
                zb[1][1] = (z43 - z42) * b2;
                if (jy == lym1) {
                    zb[0][3] = (2. * zb[0][2]) - zb[0][1];
                    zb[1][3] = (2. * zb[1][2]) - zb[1][1];
                }
            }
            if (jy < lym1) {
                y5 = y[jy + 1];
                b4 = 1. / (y5 - y4);
                z35 = z[(jx - 1) + ((jy + 1) * lx)];
                z45 = z[jx + ((jy + 1) * lx)];
                zb[0][3] = (z35 - z34) * b4;
                zb[1][3] = (z45 - z44) * b4;
                if (jy == 1) {
                    zb[0][1] = (2. * zb[0][2]) - zb[0][3];
                    zb[1][1] = (2. * zb[1][2]) - zb[1][3];
                }
            }
            zab[1][0] = (zb[1][1] - zb[0][1]) * a3;
            zab[1][2] = (zb[1][3] - zb[0][3]) * a3;
            if (jy > 2) {
                b1 = 1. / (y2 - y[jy - 3]);
                zb[0][0] = (z32 - z[(jx - 1) + ((jy - 3) * lx)]) * b1;
                zb[1][0] = (z42 - z[jx + ((jy - 3) * lx)]) * b1;
            } else {
                zb[0][0] = (2. * zb[0][1]) - zb[0][2];
                zb[1][0] = (2. * zb[1][1]) - zb[1][2];
            }
            if (jy < (ly - 2)) {
                b5 = 1. / (y[jy + 2] - y5);
                zb[0][4] = (z[(jx - 1) + ((jy + 2) * lx)] - z35) * b5;
                zb[1][4] = (z[jx + ((jy + 2) * lx)] - z45) * b5;
            } else {
                zb[0][4] = (2. * zb[0][3]) - zb[0][2];
                zb[1][4] = (2. * zb[1][3]) - zb[1][2];
            }
            if (jx < lxm1) {
                if (jy > 1) {
                    zab[2][0] = ((z53 - z[(jx + 1) + ((jy - 2) * lx)]) * b2 - zb[1][1]) * a4;
                    if (jy < lym1) {
                        zab[2][2] = ((z[(jx + 1) + ((jy + 1) * lx)] - z54) * b4 - zb[1][3]) * a4;
                    } else {
                        zab[2][2] = (2. * zab[2][1]) - zab[2][0];
                    }
                } else {
                    zab[2][2] = ((z[(jx + 1) + ((jy + 1) * lx)] - z54) * b4 - zb[1][3]) * a4;
                    zab[2][0] = (2. * zab[2][1]) - zab[2][2];
                }
                if (jx == 1) {
                    zab[0][0] = (2. * zab[1][0]) - zab[2][0];
                    zab[0][2] = (2. * zab[1][2]) - zab[2][2];
                }
            }
            if (jx > 1) {
                if (jy > 1) {
                    zab[0][0] = (zb[0][1] - (z23 - z[(jx - 2) + ((jy - 2) * lx)]) * b2) * a2;
                    if (jy < lym1) {
                        zab[0][2] = (zb[0][3] - (z[(jx - 2) + ((jy + 1) * lx)] - z24) * b4) * a2;
                    } else {
                        zab[0][2] = (2. * zab[0][1]) - zab[0][0];
                    }
                } else {
                    zab[0][2] = (zb[0][3] - (z[(jx - 2) + ((jy + 1) * lx)] - z24) * b4) * a2;
                    zab[0][0] = (2. * zab[0][1]) - zab[0][2];
                }
                if (jx == lxm1) {
                    zab[2][0] = (2. * zab[1][0]) - zab[0][0];
                    zab[2][2] = (2. * zab[1][2]) - zab[0][2];
                }
            }
            for (jy = 1; jy < 3; jy++) {
                for (jx = 1; jx < 3; jx++) {
                    w2 = Math.abs(za[jx + 2][jy - 1] - za[jx + 1][jy - 1]);
                    w3 = Math.abs(za[jx][jy - 1] - za[jx - 1][jy - 1]);
                    sw = w2 + w3;
                    if (sw >= 1.e-7) {
                        wx2 = w2 / sw;
                        wx3 = w3 / sw;
                    } else {
                        wx2 = 0.5;
                        wx3 = 0.5;
                    }
                    zx[jx][jy] = wx2 * za[jx][jy - 1] + wx3 * za[jx + 1][jy - 1];
                    w2 = Math.abs(zb[jx - 1][jy + 2] - zb[jx - 1][jy + 1]);
                    w3 = Math.abs(zb[jx - 1][jy] - zb[jx - 1][jy - 1]);
                    sw = w2 + w3;
                    if (sw >= 1.e-7) {
                        wy2 = w2 / sw;
                        wy3 = w3 / sw;
                    } else {
                        wy2 = 0.5;
                        wy3 = 0.5;
                    }
                    zy[jx][jy] = wy2 * zb[jx - 1][jy] + wy3 * zb[jx - 1][jy + 1];
                    zxy[jx][jy] = wy2 * (wx2 * zab[jx - 1][jy - 1] + wx3 * zab[jx][jy - 1]) +
                        wy3 * (wx2 * zab[jx - 1][jy] + wx3 * zab[jx][jy]);
                }
            }
            if (ix == 0) {
                w2 = a4 * (3. * a3 + a4);
                w1 = 2. * a3 * (a3 - a4) + w2;
                for (jy = 1; jy < 3; jy++) {
                    zx[0][jy] = (w1 * za[0][jy - 1] + w2 * za[1][jy - 1]) / (w1 + w2);
                    zy[0][jy] = (2. * zy[1][jy]) - zy[2][jy];
                    zxy[0][jy] = (2. * zxy[1][jy]) - zxy[2][jy];
                    for (jx1 = 1; jx1 < 3; jx1++) {
                        jx = 3 - jx1;
                        zx[jx][jy] = zx[jx - 1][jy];
                        zy[jx][jy] = zy[jx - 1][jy];
                        zxy[jx][jy] = zxy[jx - 1][jy];
                    }
                }
                x3 -= 1. / a4;
                z33 -= za[1][0] / a4;
                for (jy = 0; jy < 5; jy++) {
                    zb[1][jy] = zb[0][jy];
                }
                for (jy = 1; jy < 4; jy++) {
                    zb[0][jy] -= zab[0][jy - 1] / a4;
                }
                a3 = a4;
                za[2][0] = za[1][0];
                for (jy = 0; jy < 3; jy++) {
                    zab[1][jy] = zab[0][jy];
                }
            }
            if (ix == lx) {
                w4 = a2 * (3. * a3 + a2);
                w5 = 2. * a3 * (a3 - a2) + w4;
                for (jy = 1; jy < 3; jy++) {
                    zx[3][jy] = (w4 * za[3][jy - 1] + w5 * za[4][jy - 1]) / (w4 + w5);
                    zy[3][jy] = (2. * zy[2][jy]) - zy[1][jy];
                    zxy[3][jy] = (2. * zxy[2][jy]) - zxy[1][jy];
                    for (jx = 1; jx < 3; jx++) {
                        zx[jx][jy] = zx[jx + 1][jy];
                        zy[jx][jy] = zy[jx + 1][jy];
                        zxy[jx][jy] = zxy[jx + 1][jy];
                    }
                }
                x3 = x4;
                z33 = z43;
                for (jy = 0; jy < 5; jy++) {
                    zb[0][jy] = zb[1][jy];
                }
                a3 = a2;
                za[2][0] = za[3][0];
                for (jy = 0; jy < 3; jy++) {
                    zab[1][jy] = zab[2][jy];
                }
            }
            if (iy == 0) {
                w2 = b4 * (3. * b3 + b4);
                w1 = 2. * b3 * (b3 - b4) + w2;
                for (jx = 1; jx < 3; jx++) {
                    if (((ix > 0) || (jx == 2)) && ((ix < lx) || (jx == 1))) {
                        zy[jx][0] = (w1 * zb[jx - 1][0] + w2 * zb[jx - 1][1]) / (w1 + w2);
                        zx[jx][0] = (2. * zx[jx][1]) - zx[jx][2];
                        zxy[jx][0] = (2. * zxy[jx][1]) - zxy[jx][2];
                    }
                    for (jy1 = 1; jy1 < 3; jy1++) {
                        jy = 3 - jy1;
                        zy[jx][jy] = zy[jx][jy - 1];
                        zx[jx][jy] = zx[jx][jy - 1];
                        zxy[jx][jy] = zxy[jx][jy - 1];
                    }
                }
                y3 -= 1. / b4;
                z33 -= zb[0][1] / b4;
                za[2][0] -= zab[1][0] / b4;
                zb[0][2] = zb[0][1];
                zab[1][1] = zab[1][0];
                b3 = b4;
                if ((ix == 0) || (ix == lx)) {
                    if (ix == 0) {
                        jx = 1;
                        jx1 = 2;
                    } else {
                        jx = 2;
                        jx1 = 1;
                    }
                    jx1 = Math.floor(jx1);
                    zx[jx][1] = zx[jx1][1] + zx[jx][2] - zx[jx1][2];
                    zy[jx][1] = zy[jx1][1] + zy[jx][2] - zy[jx1][2];
                    zxy[jx][1] = zxy[jx1][1] + zxy[jx][2] - zxy[jx1][2];
                }
            }
            if (iy == ly) {
                w4 = b2 * (3. * b3 + b2);
                w5 = 2. * b3 * (b3 - b2) + w4;
                for (jx = 1; jx < 3; jx++) {
                    if (((ix > 0) || (jx == 2)) && ((ix < lx) || (jx == 1))) {
                        zy[jx][3] = (w4 * zb[jx - 1][3] + w5 * zb[jx - 1][4]) / (w4 + w5);
                        zx[jx][3] = (2. * zx[jx][2]) - zx[jx][1];
                        zxy[jx][3] = (2. * zxy[jx][2]) - zxy[jx][1];
                    }
                    for (jy = 1; jy < 3; jy++) {
                        zy[jx][jy] = zy[jx][jy + 1];
                        zx[jx][jy] = zx[jx][jy + 1];
                        zxy[jx][jy] = zxy[jx][jy + 1];
                    }
                }
                y3 = y4;
                z33 += zb[0][2] / b3;
                za[2][0] += zab[1][1] / b3;
                zb[0][2] = zb[0][3];
                zab[1][1] = zab[1][2];
                b3 = b2;
                if ((ix == 0) || (ix == lx)) {
                    if (ix == 0) {
                        jx = 1;
                        jx1 = 2;
                    } else {
                        jx = 2;
                        jx1 = 1;
                    }
                    zx[jx][2] = zx[jx1][2] + zx[jx][1] - zx[jx1][1];
                    zy[jx][2] = zy[jx1][2] + zy[jx][1] - zy[jx1][1];
                    zxy[jx][2] = zxy[jx1][2] + zxy[jx][1] - zxy[jx1][1];
                }
            }
            zx3b3 = (zx[1][2] - zx[1][1]) * b3;
            zx4b3 = (zx[2][2] - zx[2][1]) * b3;
            zy3a3 = (zy[2][1] - zy[1][1]) * a3;
            zy4a3 = (zy[2][2] - zy[1][2]) * a3;
            a = zab[1][1] - zx3b3 - zy3a3 + zxy[1][1];
            b = zx4b3 - zx3b3 - zxy[2][1] + zxy[1][1];
            c = zy4a3 - zy3a3 - zxy[1][2] + zxy[1][1];
            d = zxy[2][2] - zxy[2][1] - zxy[1][2] + zxy[1][1];
            e = a + a - b - c;
            a3sq = a3 * a3;
            b3sq = b3 * b3;
            p02 = (2. * (zb[0][2] - zy[1][1]) + zb[0][2] - zy[1][2]) * b3;
            p03 = (-2. * zb[0][2] + zy[1][2] + zy[1][1]) * b3sq;
            p12 = (2. * (zx3b3 - zxy[1][1]) + zx3b3 - zxy[1][2]) * b3;
            p13 = (-2. * zx3b3 + zxy[1][2] + zxy[1][1]) * b3sq;
            p20 = (2. * (za[2][0] - zx[1][1]) + za[2][0] - zx[2][1]) * a3;
            p21 = (2. * (zy3a3 - zxy[1][1]) + zy3a3 - zxy[2][1]) * a3;
            p22 = (3. * (a + e) + d) * a3 * b3;
            p23 = (-3. * e - b - d) * a3 * b3sq;
            p30 = (-2. * za[2][0] + zx[2][1] + zx[1][1]) * a3sq;
            p31 = (-2. * zy3a3 + zxy[2][1] + zxy[1][1]) * a3sq;
            p32 = (-3. * e - c - d) * b3 * a3sq;
            p33 = (d + e + e) * a3sq * b3sq;
        }
        dy = v[k] - y3;
        q0 = z33 + dy * (zy[1][1] + dy * (p02 + dy * p03));
        q1 = zx[1][1] + dy * (zxy[1][1] + dy * (p12 + dy * p13));
        q2 = p20 + dy * (p21 + dy * (p22 + dy * p23));
        q3 = p30 + dy * (p31 + dy * (p32 + dy * p33));
        dx = u[k] - x3;
        w[k] = q0 + dx * (q1 + dx * (q2 + dx * q3));

    }

}  // end itplbv function ---------------------------------------------------------------------


function tvfmfs_metric(erp, haat, channel, field, distance, fs_or_dist, curve, flag) {
	// console.log(`erp: ${erp}\thaat: ${haat}\tchannel: ${channel}\tfield: ${field}\tdistance: ${distance}\tfs_or_dist: ${fs_or_dist}\tcurve: ${curve}\tflag: ${flag}`)
    var id50 = 25;
    var ih50 = 13;
    var id10 = 31;
    var ih10 = 13;
    var range = 100.;
    var delta = 0.5;
    var erp_db = 0.0;
    var d_first = 0.0;
    var d_last = 0.0;
    var e_volts_meter = 0.0;
    var n_points = 1001;

    var distanceFreeSpace = 0.0;  ////////

	// if (!erp) erp = 0

    //var erp_copy = erp;
    //var distance_copy = distance;
    //var field_copy = field;

    var i = 0;
    var j = 1;

    var d = [];
    var h = [];
    var f = [];
    var f5050 = [];
    var f5010 = [];

    //For F(50,90) curves
    var L = 50.0;
    var T = 90.0;
    var ZQ = 0.0;
    var sigma = 0.0;
    var RL = 0.0;
    var RT = 0.0;

    //var flag = [];

    for (i = 0; i < 19; i++) flag[i] = 0;


    // Input data checks

    if ((channel < 2 || channel > 300) || (channel > 69 && channel < 200) || channel == '') {
        console.log('FLAg 3')
        flag[3] = 1;
    }
    if (erp < 0.0001) {
        flag[6] = 1;
        if (erp < 0.0001 && erp > 0.00000001) {
            erp = 0.0001;
        }
    }

    if (((channel >= 2 && channel <= 6) || (channel >= 200 && channel <= 300)) && (erp > 400.5)) {
        flag[12] = 1;
    } else if ((channel >= 7 && channel <= 13) && (erp > 400.5)) {
        flag[13] = 1;
    } else if ((channel >= 14 && channel <= 69) && (erp > 5500.5)) {
        flag[14] = 1;
    }

    if ((curve == 0 || curve == 2) && distance > 300.) {
        flag[15] = 1;
    } else if (curve == 1 && distance > 500.) {
        flag[16] = 1;
    }

    if (curve < 0 || curve > 2 || curve === '') {
        console.log('FLAG 4')
        console.log(curve === '')
        flag[4] = 1;
    }
    if (fs_or_dist < 1 || fs_or_dist > 3 || fs_or_dist == '') {
        flag[5] = 1;
    }
    if (fs_or_dist == 1 && field < 0.0) {
        flag[9] = 1;
        field = Math.abs(field);
    }
    if (fs_or_dist == 2 && distance < 0.0) {
        flag[9] = 1;
        distance = Math.abs(distance);
    }

    if (fs_or_dist == 3)  //find FM ERP, given a HAAT and a distance
    {
        var field_for_erp = 60.;       // 60 dBu used to determin equivalence
        erp = 1.0;                     // initial value
        if (channel < 200) flag[17] = 1;  // No TV calculations here
        curve = 0;                     // Service contour only
        channel = 250;
    }

    erp_db = 10.0 * (Math.log(erp) / Math.log(10));
    // Math.log(x)/Math.log(10) = log10(x) which is not supported in some browsers

    if (haat < 30.0) {
        haat = 30.0;
        flag[7] = 1;
    }  // All HAAT below 30 meters are set to 30
    else if (haat > 1600) {
        haat = 1600.;
        flag[8] = 1;
    }  // All HAAT above 1600 are set to 1600

    if (flag[3] == 1 || flag[4] == 1 || flag[5] == 1) {

        return flag;
    } //need more info -- NO CALCULATIONS
    else if (flag[12] == 1 || flag[13] == 1 || flag[14] == 1 || flag[15] == 1 || flag[16] == 1 || flag[17] == 1) {
        return flag;
    } //need more info -- NO CALCULATIONS

    /***********************************************************************
     !     FOR fs_or_dist = 1, FIND THE "FIELD" AT THE DISTANCE SPECIFIED IN    *
     !     "DISTANCE".  IF THE DISTANCE IS LESS THAN 1.5 KM, USE THE FREE   *
     !     SPACE EQUATION.                                                  *
     !**********************************************************************/

    if (fs_or_dist == 1 || fs_or_dist == 3) {

        n_points = 1;
        j = 1;
        if (distance < 1.5) {
            field = (106.92 - (20.0 * (Math.log(distance) / Math.log(10)))) + erp_db;
            // Math.log(x)/Math.log(10) = log10(x) which is not supported in some browsers (Internet Explorer)

            flag[1] = 1;

            return field;

        }
        if ((curve == 0 && distance > 300.0) || (curve == 1 && distance > 500.0)) {
            flag[2] = 1;
        } else {
            h[0] = haat;       // Only one point sought
            d[0] = distance;

            RL = 0.0;

            if ((channel >= 2 && channel <= 6) || (channel >= 200 && channel <= 300)) // FM & analog TV channels 2-6
            {
                if (curve == 0 || (curve == 1 && distance < 15.0)) {
                    itplbv(id50, ih50, D50, H50, F55LV, j, d, h, f);
                } else if (curve == 1) {
                    itplbv(id10, ih10, D10, H10, F51LV, j, d, h, f);
                } else if (curve == 2) {
                    if (distance >= 15) {
                        itplbv(id50, ih50, D50, H50, F55LV, j, d, h, f5050);
                        itplbv(id10, ih10, D10, H10, F51LV, j, d, h, f5010);
                    } else if (distance < 15) {
                        itplbv(id50, ih50, D50, H50, F55LV, j, d, h, f5050);
                        f5010[0] = f5050[0]; // use F5050 curves below 15 km
                    }

                    // F(50,90) means field strength at 50% of the locations, 90% of the time
                    // Here we can alter the location variability parameter L.  This changes the field strength result.
                    // But since in practice, we never use this, it is commented out.
                    // It is retained here for reference only.

                    // if( L != 50. )
                    // {
                    //  ZQ = fzq(L);
                    //  sigma = 11.88; // > 470 MHz
                    //  RL = ZQ * sigma;
                    // }
                }
            } else if (channel >= 7 && channel <= 13) {
                if (curve == 0 || (curve == 1 && distance < 15.0)) {
                    itplbv(id50, ih50, D50, H50, F55HV, j, d, h, f);
                } else if (curve == 1) {
                    itplbv(id10, ih10, D10, H10, F51HV, j, d, h, f);
                } else if (curve == 2) {
                    if (distance >= 15) {
                        itplbv(id50, ih50, D50, H50, F55HV, j, d, h, f5050);
                        itplbv(id10, ih10, D10, H10, F51HV, j, d, h, f5010);
                    } else if (distance < 15) {
                        itplbv(id50, ih50, D50, H50, F55HV, j, d, h, f5050);
                        f5010[0] = f5050[0]; // use F5050 curves below 15 km
                    }

                    // F(50,90) means field strength at 50% of the locations, 90% of the time
                    // Here we can alter the location variability parameter L.  This changes the field strength result.
                    // But since in practice, we never use this, it is commented out.
                    // It is retained here for reference only.

                    // if( L != 50. )
                    // {
                    //  ZQ = fzq(L);
                    //  sigma = 11.88; // > 470 MHz
                    //  RL = ZQ * sigma;
                    // }
                }

            } else if (channel >= 14 && channel <= 69) {
                if (curve == 0 || (curve == 1 && distance < 15.0)) //F(50,50)
                {
                    itplbv(id50, ih50, D50, H50, F55U, j, d, h, f);
                } else if (curve == 1) // F(50,10)
                {
                    itplbv(id10, ih10, D10, H10, F51U, j, d, h, f);
                } else if (curve == 2)  // F(50,90)
                {
                    if (distance >= 15) {
                        itplbv(id50, ih50, D50, H50, F55U, j, d, h, f5050);
                        itplbv(id10, ih10, D10, H10, F51U, j, d, h, f5010);
                    } else if (distance < 15) {
                        itplbv(id50, ih50, D50, H50, F55U, j, d, h, f5050);
                        f5010[0] = f5050[0]; // use F5050 curves below 15 km
                    }

                    // F(50,90) means field strength at 50% of the locations, 90% of the time
                    // Here we can alter the location variability parameter L.  This changes the field strength result.
                    // But since in practice, we never use this, it is commented out.
                    // It is retained here for reference only.

                    // if( L != 50. )
                    // {
                    //  ZQ = fzq(L);
                    //  sigma = 11.88; // > 470 MHz
                    //  RL = ZQ * sigma;
                    // }
                }
            }
        }
        if (flag[1] == 1) {
            ;
        }  // no changes to field value
        if (curve == 0 || curve == 1) {
            field = f[0] + erp_db;
        } else if (curve == 2) {
            ZQ = fzq(T);

            RT = (f5010[0] - f5050[0]) * (ZQ / 1.28155);

            field = f5050[0] + RL + RT + erp_db;
        }

        if (fs_or_dist == 3)  // then we find the FM ERP in kW and return that
        {
            erp = Math.pow(10, ((field_for_erp - field) / 10.));

            if (erp > 100) flag[10] = 1;

            return erp;
        } else {
            return field;
        }


    } // end fs_or_dist == 1

    /***********************************************************************
     !     FOR fs_or_dist = 2, THE "DISTANCE" FOR A SPECIFIED "FIELD" VALUE IS
     !     FOUND BY COMPUTING A FIELD VS. DISTANCE CURVE AT
     !     INCREMENTS OF 0.5 KILOMETER AND THEN FINDING THE CORRECT DISTANCE VALUE
     !     BY  INTERPOLATING BETWEEN THE FIELD POINTS.
     !***********************************************************************/

    else if (fs_or_dist == 2) {
        j = n_points;

        for (i = 0; i <= n_points; i++) {
            h[i] = haat;
            f5050[i] = f5010[i] = f[i] = d[i] = 0.0;
        }

        if (curve == 0 || curve == 2) {
            d_first = 1.5;
            d_last = 300.0;
        } else if (curve == 1) {
            d_first = 15.0;
            d_last = 500.0;
        }
        var k = Math.floor(d_first / delta);
        for (i = k; i <= n_points; i++) {
            d[i] = (i * delta);
        }  // d_first/delta must be an integer

        //continue110:

        if ((channel >= 2 && channel <= 6) || (channel >= 200 && channel <= 300)) {
            if (curve == 0) {
                itplbv(id50, ih50, D50, H50, F55LV, j, d, h, f);
            } else if (curve == 1) {
                itplbv(id10, ih10, D10, H10, F51LV, j, d, h, f);
            } else if (curve == 2) {
                itplbv(id50, ih50, D50, H50, F55LV, j, d, h, f5050);
                itplbv(id10, ih10, D10, H10, F51LV, j, d, h, f5010);

                // F(50,90) means field strength at 50% of the locations, 90% of the time
                // Here we can alter the location variability parameter L.  This changes the field strength result.
                // But since in practice, we never use this, it is commented out.
                // It is retained here for reference only.

                // if( L != 50. )
                // {
                //  ZQ = fzq(L);
                //  sigma = 11.88; // > 470 MHz
                //  RL = ZQ * sigma;
            }

        } else if (channel >= 7 && channel <= 13) {
            if (curve == 0) {
                itplbv(id50, ih50, D50, H50, F55HV, j, d, h, f);
            } else if (curve == 1) {
                itplbv(id10, ih10, D10, H10, F51HV, j, d, h, f);
            } else if (curve == 2) {
                itplbv(id50, ih50, D50, H50, F55HV, j, d, h, f5050);
                itplbv(id10, ih10, D10, H10, F51HV, j, d, h, f5010);

                // F(50,90) means field strength at 50% of the locations, 90% of the time
                // Here we can alter the location variability parameter L.  This changes the field strength result.
                // But since in practice, we never use this, it is commented out.
                // It is retained here for reference only.

                // if( L != 50. )
                // {
                //  ZQ = fzq(L);
                //  sigma = 11.88; // > 470 MHz
                //  RL = ZQ * sigma;
            }

        } else if (channel >= 14 && channel <= 69) {
            if (curve == 0) {
                itplbv(id50, ih50, D50, H50, F55U, j, d, h, f);
            } else if (curve == 1) {
                itplbv(id10, ih10, D10, H10, F51U, j, d, h, f);
            } else if (curve == 2) {
                itplbv(id50, ih50, D50, H50, F55U, j, d, h, f5050);
                itplbv(id10, ih10, D10, H10, F51U, j, d, h, f5010);

                // F(50,90) means field strength at 50% of the locations, 90% of the time
                // Here we can alter the location variability parameter L.  This changes the field strength result.
                // But since in practice, we never use this, it is commented out.
                // It is retained here for reference only.

                // if( L != 50. )
                // {
                //  ZQ = fzq(L);
                //  sigma = 11.88; // > 470 MHz
                //  RL = ZQ * sigma;
            }
        }

        if (curve == 1 || curve == 2)  // add in the 3 to 15 km range to the f field strength array
                                       // for F(50,10) interfering contours only.  Since the F(50,10) interfering
                                       // contours start at 15 km, we use the F(50,50) curves in this range.
        {
            var d1 = [];
            var f1 = [];  //alert(channel);

            for (i = 0; i < 30; i++) f[i] = 0.0;
            for (i = 0; i < n_points; i++) {
                d1[i] = (i * delta);
                f1[i] = 0.0;
            }

            if ((channel >= 2 && channel <= 6) || (channel >= 200 && channel <= 300)) {
                itplbv(id50, ih50, D50, H50, F55LV, j, d1, h, f1);
            } else if (channel >= 7 && channel <= 13) {
                itplbv(id50, ih50, D50, H50, F55HV, j, d1, h, f1);
            } else if (channel >= 14 && channel <= 69) {
                itplbv(id50, ih50, D50, H50, F55U, j, d1, h, f5050);
            }

            //i=i for FM vhf uhf

            for (i = 0; i < 30; i++) {
                if (curve == 1) {
                    f[i] = f1[i] * 1.0;
                } else if (curve == 2) {
                    f[i] = f5010[i] = f5050[i] * 1.0;
                }

                d[i] = (i * delta);
            }

            ////for(i=0; i<35; i++) document.write(f[i] + '  ' + i + '  ' + f1[i] + '  ' + d[i] + '<br>');

        }

// alert(f[0]);

        if (field > f[0])  // Check for High field strength, very close to transmitter site // Service AND Interfering contours.
        // If true, no interpolation possible since value is outside the f[i] values range (point is off the curve).
        {               // Use the free space equation to find the field strength and distance
            flag[1] = 1;
            e_volts_meter = 1.0e-6 * Math.pow(10, (field / 20.));
            distance = (7.014271e-3 * Math.sqrt(erp * 1000.)) / e_volts_meter;

            // Added 9/2004 to prevent free space distance from exceeding minimum curves distance of
            // 1.5 km (to eliminate the discontinuity between the free space and curves values)
            // if(distance >= 1.5) { distance = 1.5; flag[1] = 0; }

            return distance;

        } else (field <= f[0])  // usual case
        {

            for (i = 1; i < n_points; i++) // initially assume points i=0,1,2 not covered by free space equation immediately below
            {
                if (curve == 0 || curve == 1) {
                    f[i] = f[i] + erp_db;
                } else if (curve == 2) {
                    ZQ = fzq(T);  // T is the time variable in F(50,90) = the 90
                    RT = (f5010[i] - f5050[i]) * (ZQ / 1.28155);

                    f[i] = f5050[i] + RL + RT + erp_db;
                }
            }

            // Continuing, for service and interfering contours

            for (i = 1; i < n_points; i++)  // start at 1 because of i-1
            {
                if (field >= f[i] && field <= f[i - 1]) // field values decrease on graph as i increases
                {
                    // TEST to see what we have:
                    // alert(i + '  f[i-1]='  + f[i-1] + '  field=' + field + '  f[i]=' + f[i] + '  d[i]=' + d[i] + '  d[i-1]=' + d[i-1]);

                    if (d[i] <= 1.5) // free space equation
                    {
                        flag[1] = 1;
                        e_volts_meter = 1.0e-6 * Math.pow(10, (field / 20.));
                        distance = (7.014271e-3 * Math.sqrt(erp * 1000.)) / e_volts_meter;
                    } else // linear interpolation
                    {
                        distance = (((f[i - 1] - field) / (f[i - 1] - f[i])) * (d[i] - d[i - 1])) + d[i - 1];
                    }

                    if (distance > d_last) {
                        flag[2] = 1;
                    }  // off upper end of curve // not common

                    console.log(`### distance: ${distance}`)
                    return distance;
                }
            }
        }
        // should not get here!

    } // end distance
} // end tvfmfs_metric ----------------------------------------------------------------------------------

function tvfmfs_comment(i) {
    var comment;
    if (i == 0) comment = "";
    else if (i == 1) comment = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Free Space equation used to compute distance.<br>\n ";
    else if (i == 2) comment = "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entered distance exceeds maximum curve distance.<br>\n";
    else if (i == 3) comment = "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select a channel range.<br>\n";
    else if (i == 4) comment = "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select a contour type.<br>\n";
    else if (i == 5) comment = "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select the desired result (Find This).<br>\n";
    else if (i == 6) comment = "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERP of less than 0.0001 kW (0.1 watt) is changed to 0.0001 kW for calculations.<br>\n";
    else if (i == 7) comment = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entered HAAT is less than 30 meters; changed to 30 meters for calculations.<br>\n";
    else if (i == 8) comment = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entered HAAT is greater than 1600 meters; changed to 1600 meters for calculations.<br>\n";
    else if (i == 9) comment = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entered Field or Distance is less than zero; set to positive for calculations.<br>\n";
    else if (i == 10) comment = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERP exceeds the maximum of 100 kW permitted for U.S. FM stations. <br>\n";
    else if (i == 11) comment = "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Non-numeric data entered in a form input. <br>\n";

    else if (i == 12) comment = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum ERP for VHF, TV Channels 2-6, is 400 kW. <br>\n";
    else if (i == 13) comment = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum ERP for VHF, TV Channels 7-13, is 400 kW. <br>\n";
    else if (i == 14) comment = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum ERP for UHF, TV Channels 14-69, is 5500 kW. <br>\n";

    else if (i == 15) comment = "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum curve <b>distance</b> for service contours is limited to 300 km. <br>\n";
    else if (i == 16) comment = "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum curve <b>distance</b> for interfering contours is limited to 500 km.<br>\n";

    else if (i == 17) comment = "<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 'Find ERP' calculation is not valid for the TV service.<br>\n";
    else if (i == 18) comment = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum ERP for VHF, FM Channel 6, is 400 kW. <br>\n";

    else if (i == 19) comment = "Feature not yet implemented."
    else comment = "";
    return comment;
}


function fzq(Q) // for F(50,90) curves prediction
{
    var k;
    var ZGRID = [];

    ZQ = 0.0; // Initialize

    for (k = 0; k <= 57; k++) {
        ZGRID[k] = -ZGRI[k];
        ZGRID[114 - k] = ZGRI[k];
    }
    for (k = 1; k < 115; k++) {
        if (VGRID[k] < Q) {
            ;
        } else {
            ZQ = ZGRID[k - 1] + ((Q - VGRID[k - 1]) / (VGRID[k] - VGRID[k - 1])) * (ZGRID[k] - ZGRID[k - 1]);
            if (ZQ !== ZQ) ZQ = 0.0;  // Checking for NaN, set to 0 (means no curve shifts for Q)
            return ZQ;
        }
    }

}   // end fzq


function round_power(power_in, error_flag) {

    /************************************************************************
     *
     *     This subroutine will round the power in accordance with the FCC
     *     Rules section 73.212.
     *
     *     POWER_IN   = Unrounded power in Watts or kilowatts; real; input.
     *     POWER_OUT  = Rounded power in Watts or kilowatts; real; output.
     *     ERROR_FLAG = 0; no errors; integer; output.
     *                = 1; Input power is less than minimum allowed,
     *                     POWER_OUT set equal to POWER_IN.
     *                = 2; Input power greater than maximum allowed,
     *                     POWER_OUT set equal to POWER_IN.
     *
     *                     ...kalagian...11/3/86...
     *
     ***********************************************************************/

    var power_out = 0.0;
    var round_factor = 0.0;

    error_flag = 0;
    power_out = power_in + 0.000000000001;  // to insure a nonzero power_in

    if (power_in >= 0.001 && power_in < 0.003) {
        round_factor = 0.00005;
    } else if (power_in >= 0.003 && power_in < 0.01) {
        round_factor = 0.0001;
    } else if (power_in >= 0.01 && power_in < 0.03) {
        round_factor = 0.0005;
    } else if (power_in >= 0.03 && power_in < 0.1) {
        round_factor = 0.001;
    } else if (power_in >= 0.10 && power_in < 0.3) {
        round_factor = 0.005;
    } else if (power_in >= 0.30 && power_in < 1.0) {
        round_factor = 0.01;
    } else if (power_in >= 1.0 && power_in < 3.0) {
        round_factor = 0.05;
    } else if (power_in >= 3.00 && power_in < 10.) {
        round_factor = 0.1;
    } else if (power_in >= 10.0 && power_in < 30.) {
        round_factor = 0.5;
    } else if (power_in >= 30. && power_in < 100.) {
        round_factor = 1.;
    } else if (power_in >= 100. && power_in < 300.) {
        round_factor = 5.;
    } else if (power_in >= 300. && power_in < 1000.) {
        round_factor = 10.0;
    }

    power_out = power_in / round_factor;
    power_out = Math.floor(Math.round(power_out));
    power_out = power_out * round_factor;

    if (power_in > 1000.) {
        power_out = Math.floor(power_in);
    }

    return (power_out);
}

function getResult(req, res, callback) {
    console.log('================ Start CURVES API ===================');
    /*
	 * Refactored 6/20/18 by Sam Bressi
	 * Instead of calling getDistance directly, the input validations
	 *  are wrapped in a getResults wrapper, which adds in the computationMethod.
	 *
	 * The computationMethod is 0, 1, or 2 depending on if the user wants
	 *  to calculate the distance, field strength, or maximum ERP.
	 *
	 * Using computationMethod 0 calls getDistance and the API should work as
	 *  originally built. New functionality added in to call getFieldStrength
	 *  and getMaxPower when computation method is 1 or 2 respectively.
	 */
    try {
        var haat = req.query.haat;
        var field = req.query.field;
        var erp = req.query.erp;
        var distance = req.query.distance;
        var channel = req.query.channel;
        var curve = req.query.curve;
        var serviceType = req.query.serviceType;
        var computationMethod = req.query.computationMethod;

        var dataObj = new Object;
        dataObj['status'] = 'error';
        dataObj['statusCode'] = '400';
        dataObj['statusMessage'] = '';

        // *** REQUIRED FIELD CHECKS *** //
        // *** SERVICE TYPE CHECKS *** //
        if (serviceType == undefined) {
            console.log('Missing serviceType');
            dataObj.statusMessage = 'Missing serviceType parameter.';
            return callback(dataObj);
        }

        serviceType = serviceType.toLowerCase();

        // *** COMPUTATION METHOD CHECKS *** //
        // Valid values:
        // 0: distance (default)
        // 1: field strength
        // 2: max ERP
        if (computationMethod == undefined) {
            computationMethod = '0';
            console.log('Computation method not provided. Forcing 0 (distance) for backward compatibility.');
        }

        if (!computationMethod.match(/^\d+$/)) {
            console.log('invalid computationMethod value');
            dataObj.statusMessage = 'Invalid computationMethod value.';
            return callback(dataObj);
        }

        computationMethod = parseFloat(computationMethod);

        if (computationMethod < 0 || computationMethod > 2) {
            console.log('Computation method value out of range [0, 2]');
            dataObj.statusMessage = 'Computation method value out of range [0, 2].';
            return callback(dataObj);
        }

        var tv_fm_list = ['tv', 'fm'];
        if (tv_fm_list.indexOf(serviceType) < 0) {
            console.log('invalid serviceType value');
            dataObj.statusMessage = 'Invalid serviceType value.';
            return callback(dataObj);
        }

        // *** HAAT CHECKS *** //
        if (haat == undefined) {
            console.log('Missing haat');
            dataObj.statusMessage = 'Missing haat.';
            return callback(dataObj);
        }

        // ** Ahmad Aburizaiza **
        // the regexp fixed to include negative numbers
        if (!haat.match(/^-?\d+\.?\d*$/)) {
            console.log('invalid haat value');
            dataObj.statusMessage = 'Invalid haat value.';
            return callback(dataObj);
        }

        if (parseFloat(haat) > 1600.0) {
            console.log('HAAT value out of range ( > 1600)');
            dataObj.statusMessage = 'HAAT value cannot exceed 1600.';
            return callback(dataObj);
        }

        // *** CHANNEL CHECKS *** //
        if (channel == undefined) {
            if (serviceType == 'tv') {
                console.log('Missing channel');
                dataObj.statusMessage = 'Missing channel.';
                return callback(dataObj);
            } else if ((serviceType == 'fm') && ((computationMethod == 0) || (computationMethod == 1))) {
                channel = '6';
            } else {
                channel = '250';
            }
        }

        if (channel && !channel.match(/\d+$/)) {
            console.log('invalid channel value');
            dataObj.statusMessage = 'Invalid channel value.';
            return callback(dataObj);
        }

        /*
		if(serviceType === 'fm' && (channel !== '6' || channel == undefined)){
			console.log('Channel 6 is the only valid channel for FM services');
			dataObj.statusMessage = 'Only channel 6 allowed for FM services';
			return callback(dataObj);
		}
		*/

        // *** CURVE CHECKS *** //
        // Valid values:
        // 0: F(50,50)
        // 1: F(50,10)
        // 2: F(50,90)
        if (curve == undefined) {
            console.log('Missing curve');
            dataObj.statusMessage = 'Missing curve.';
            return callback(dataObj);
        }

        if (!curve.match(/^\d+$/)) {
            console.log('invalid curve value');
            dataObj.statusMessage = 'Invalid curve value.';
            return callback(dataObj);
        }

        if (parseFloat(curve) < 0 || parseFloat(curve) > 2) {
            console.log('Curve value out of range [0, 2]');
            dataObj.statusMessage = 'Curve value out of range [0, 2].';
            return callback(dataObj);
        }

        haat = parseFloat(haat);
        channel = parseFloat(channel);
        curve = parseFloat(curve);

        // ** Ahmad Aburizaiza **
        // update the value of haat to 30 if it is less than 30
        // the value is updated in tvfmfs_metric(..) but not returned
        // for the post code that requires the updated haat value
        if (parseFloat(haat) < 30.0) {
            haat = 30.0;
        }

        // *** END REQUIRED FIELD CHECKS *** //

        // Determine which optional fields are needed based on the computation method
        // CM 0 (Distance) - Requires field strength and ERP
        // CM 1 (Field Strength) - Requires distance and ERP
        // CM 2 (ERP) - Requires distance and field strength
        var result = -1;

        if (computationMethod == 0) {
            if (field == undefined) {
                console.log('Mssing field strength.');
                dataObj.statusMessage = 'Missing field';
                return callback(dataObj);
            }

            if (erp == undefined) {
                console.log('Mssing erp.');
                dataObj.statusMessage = 'Missing erp';
                return callback(dataObj);
            }

            if (!field.match(/^-?\d+\.?\d*$/)) {
                console.log('Invalid field strength value.')
                dataObj.statusMessage = 'Invalid field value';
                return callback(dataObj);
            }

            if (!erp.match(/^\d+\.?\d*$/)) {
                console.log('Invalid erp value.')
                dataObj.statusMessage = 'Invalid erp value';
                return callback(dataObj);
            }

            field = parseFloat(field);
            erp = parseFloat(erp);

            result = getDistance(haat, serviceType, channel, curve, field, erp);
        } else if (computationMethod == 1) {
            if (distance == undefined) {
                console.log('Mssing distance.');
                dataObj.statusMessage = 'Missing distance';
                return callback(dataObj);
            }

            if (erp == undefined) {
                console.log('Mssing erp.');
                dataObj.statusMessage = 'Missing erp';
                return callback(dataObj);
            }

            if (!distance.match(/^-?\d+\.?\d*$/)) {
                console.log('Invalid distance value.')
                dataObj.statusMessage = 'Invalid distance value';
                return callback(dataObj);
            }

            if (!erp.match(/^\d+\.?\d*$/)) {
                console.log('Invalid erp value.')
                dataObj.statusMessage = 'Invalid erp value';
                return callback(dataObj);
            }

            distance = parseFloat(distance);
            erp = parseFloat(erp);

            result = getFieldStrength(haat, serviceType, channel, curve, erp, distance);
        } else if (computationMethod == 2) {
            if (distance == undefined) {
                console.log('Mssing distance.');
                dataObj.statusMessage = 'Missing distance';
                return callback(dataObj);
            }

            if (field == undefined) {
                console.log('Mssing field strength.');
                dataObj.statusMessage = 'Missing field';
                return callback(dataObj);
            }

            if (!distance.match(/^-?\d+\.?\d*$/)) {
                console.log('Invalid distance value.')
                dataObj.statusMessage = 'Invalid distance value';
                return callback(dataObj);
            }

            if (!field.match(/^-?\d+\.?\d*$/)) {
                console.log('Invalid field strength value.')
                dataObj.statusMessage = 'Invalid field value';
                return callback(dataObj);
            }

            distance = parseFloat(distance);
            field = parseFloat(field);
            result = getMaxPower(haat, serviceType, channel, curve, field, distance);
        }

        console.log('computationMethod=' + computationMethod);
        console.log('result=');
        console.log(result);

        if (isNaN(result)) {
            var comments = "";
            for (var i = 0; i < result.length; i++) {
                if (result[i] == 1) {
                    if (i === 12 && serviceType.toLowerCase() == 'fm') {
                        console.log('comment for item=18')
                        var comment = tvfmfs_comment(18).replace(/^.*;/, '').replace(/\..*\n/, '');
                        comments += comment + ";";
                    } else {
                        console.log('comment for item=' + i)
                        var comment = tvfmfs_comment(i).replace(/^.*;/, '').replace(/\..*\n/, '');
                        comments += comment + ";";
                    }
                }
            }

            comments = comments.replace(/;$/, '');
            dataObj.statusMessage = comments;
            return callback(dataObj);
//		} else if (result < 0) {
//			dataObj.statusMessage = 'CURVES error occurred when calculating computation method'
//			return callback(dataObj);

        } else {
            dataObj.status = 'success';
            dataObj.statusCode = '200';
            dataObj.statusMessage = 'ok';
            dataObj.haat = haat;
            dataObj.haat_unit = 'm';
            dataObj.channel = channel;
            dataObj.curve = curve;
            dataObj.serviceType = serviceType;
            dataObj.computationMethod = computationMethod;
            if (computationMethod == 0) {
                dataObj.computedField = "distance";
                dataObj.distance = mathjs.round(result, 3);
                dataObj.field = mathjs.round(field, 1);
                dataObj.erp = mathjs.round(erp, 3);
            } else if (computationMethod == 1) {
                dataObj.computedField = "field";
                dataObj.distance = mathjs.round(distance, 3);
                dataObj.field = mathjs.round(result, 3);
                dataObj.erp = mathjs.round(erp, 3);
            } else if (computationMethod == 2) {
                dataObj.computedField = "erp";
                dataObj.distance = mathjs.round(distance, 3);
                dataObj.field = mathjs.round(field, 1);
                dataObj.erp = mathjs.round(result, 3);
            }
            dataObj.distance_unit = 'km';
            dataObj.field_unit = 'dbu';
            dataObj.erp_unit = 'kw';

            return callback(dataObj);
        }


    } catch (err) {
        console.log('err=' + err);
        dataObj.error = err.stack;
        dataObj.statusMessage = 'CURVES error occurred.';
        return callback(dataObj);
    }
}

function getFieldStrength(haat, serviceType, channel, curve, erp, distance) {
    console.log('================ Start CURVES Field Strength API ===================');
    var fs_or_dist = 1;
    var flag = [];
    var field = tvfmfs_metric(erp, haat, channel, field, distance, fs_or_dist, curve, flag);
    return field;
}

function getMaxPower(haat, serviceType, channel, curve, field, distance) {
    console.log('================ Start CURVES Max ERP API ===================');
    var fs_or_dist = 1;
    var flag = [];
    var erp = 1;
    var field2 = getFieldStrength(haat, serviceType, channel, curve, erp, distance);
    var power_in = Math.pow(10, (field - field2) / 10);
    var power_out = round_power(power_in);
    return power_out;
}

function getDistance(haat, serviceType, channel, curve, field, erp) {
    console.log('================ Start CURVES Distance API ===================');
    var fs_or_dist = 2;
    var flag = [];
    var distance = tvfmfs_metric(erp, haat, channel, field, distance, fs_or_dist, curve, flag);
    return distance;
}

module.exports.tvfmfs_metric = tvfmfs_metric;
module.exports.getResult = getResult;



