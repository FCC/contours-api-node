
// **********************************************************

'use strict';

// **********************************************************

var mathjs = require('mathjs');

// To avoid ReferenceError: function not defined, these anonymous functions need
// to be declared OUTSIDE the $(document).ready function 

//---- FM and TV Propagation Curves Data ---------------------------------------------------------------

// Distance values for F(50,50) curves 
var D50 = [1.609344, 3.218688, 4.828032, 6.437376, 8.046720, 16.09344, 32.18688, 48.28032,
	64.37376, 80.46720, 96.56064, 112.65408, 128.74752, 144.84096, 160.93440, 177.02784,
	193.12128, 209.21472, 225.30816, 241.40160, 257.49504, 273.58848, 289.68192, 305.77536,
	321.86880, 0.0];

// Distance values for F(50,10) curves
// Distance of D10(31) added to smooth out the graph and interpolation
// for the F(50,10) curve at the rarely used distance of (almost) 500 km  

var D10 = [16.09344, 32.18688, 48.28032, 64.37376, 80.46720, 96.56064, 112.65408, 128.74752,
	144.84096, 160.93440, 177.02784, 193.12128, 209.21472, 225.30816, 241.40160, 257.49504,
	273.58848, 289.68192, 305.77536, 321.86880, 337.96224, 354.05568, 370.14912, 386.24256,
	402.33600, 418.42944, 434.52288, 450.61632, 466.70976, 482.80320, 498.89644, 0.0];

// Height values H10, H50 in meters 
var H50 = [30.48, 60.96, 121.92, 182.88, 243.84, 304.80, 381.00, 457.20, 533.40, 609.60, 914.40,
	1219.20, 1524.00, 0.0];

var H10 = [30.48, 60.96, 121.92, 182.88, 243.84, 304.80, 381.00, 457.20, 533.40, 609.60, 914.40,
	1219.20, 1524.00, 0.0];


/************************************************************************
!  F(50,50) FIELD STRENGTH DATA FOR THE LOW VHF PROPAGATION CURVE.  
!  (FM AND TV CHANNELS 2 THROUGH 6 )  --  (13 points * 25 curves = 325)                        *
!***********************************************************************/
// was [25][13] 

var F55LV = [92.0, 79.7, 72.7, 67.8, 64.0, 52.0, 39.4, 31.0, 25.3, 20.3, 16.2, 12.8, 9.8, 6.9, 4.0,
	1.5, -1.1, -3.6, -5.8, -8.1, -10.6, -13.0, -15.1, -17.2, -19.2, 98.0, 85.9, 79.0, 73.8, 70.0,
	58.0, 45.5, 37.0, 29.5, 23.5, 18.1, 14.5, 11.0, 8.2, 5.5, 2.9, 0.3, -2.2, -4.8, -7.0, -9.4,
	-11.7, -14.0, -16.1, -18.3, 100.6, 91.0, 84.8, 80.0, 76.0, 64.0, 51.5, 43.0, 35.5, 28.8, 22.0,
	17.1, 13.4, 10.2, 7.4, 4.8, 2.2, -0.3, -3.0, -5.2, -7.6, -10.0, -12.2, -14.6, -16.9, 101.5,
	93.4, 87.8, 83.3, 79.6, 67.6, 55.0, 46.7, 39.0, 32.0, 25.3, 19.8, 15.2, 11.8, 8.9, 6.0, 3.7,
	1.0, -1.4, -3.9, -6.1, -8.7, -11.0, -13.2, -15.6, 101.9, 94.6, 89.4, 85.4, 82.0, 70.0, 57.6,
	49.0, 41.5, 34.4, 27.7, 22.0, 17.0, 13.1, 10.1, 7.2, 4.8, 2.0, -0.3, -2.7, -5.1, -7.6, -10.0,
	-12.1, -14.6, 102.0, 95.0, 90.4, 86.8, 83.7, 72.0, 59.6, 51.0, 43.6, 36.7, 29.9, 23.9, 18.8,
	14.7, 11.5, 8.4, 5.7, 3.0, 0.6, -1.8, -4.2, -6.6, -9.0, -11.2, -13.6, 102.1, 95.6, 91.2, 87.7,
	85.0, 73.9, 61.7, 53.2, 45.9, 39.1, 32.0, 26.0, 21.0, 16.8, 13.1, 9.9, 7.0, 4.1, 1.7, -0.7,
	-3.2, -5.6, -8.0, -10.2, -12.5, 102.2, 95.9, 91.8, 88.3, 85.8, 75.4, 63.3, 55.1, 47.9, 41.5,
	34.4, 28.3, 23.2, 18.8, 14.9, 11.1, 8.0, 5.2, 2.7, 0.2, -2.2, -4.6, -7.0, -9.2, -11.6, 102.3,
	96.0, 92.0, 88.9, 86.3, 76.7, 64.9, 57.0, 50.0, 43.5, 36.7, 30.7, 25.2, 20.4, 16.0, 12.5, 9.1,
	6.2, 3.8, 1.1, -1.3, -3.6, -6.1, -8.4, -10.6, 102.4, 96.1, 92.2, 89.2, 86.7, 77.9, 66.2, 58.5,
	51.5, 45.0, 38.2, 32.4, 27.0, 22.0, 17.3, 13.7, 10.1, 7.1, 4.6, 2.0, -0.4, -2.7, -5.1, -7.6,
	-10.0, 102.5, 96.3, 92.5, 89.9, 87.6, 80.2, 70.0, 62.6, 55.4, 48.9, 42.5, 36.9, 31.0, 25.7,
	21.0, 17.1, 13.6, 10.3, 7.8, 5.1, 2.8, 0.5, -2.1, -4.5, -6.8, 102.5, 96.5, 92.5, 90.1, 88.0,
	81.3, 72.4, 65.0, 57.8, 51.2, 44.9, 39.1, 33.2, 28.1, 23.5, 19.8, 16.1, 13.0, 10.4, 8.0, 5.5,
	3.1, 0.6, -2.0, -4.1, 102.5, 96.5, 92.5, 90.2, 88.1, 81.9, 74.2, 66.5, 59.6, 53.0, 46.4, 40.8,
	35.0, 30.0, 25.5, 21.8, 18.3, 15.0, 12.4, 10.0, 7.7, 5.1, 2.8, 0.2, -2.0];


/***********************************************************************
!  F(50,10)  FIELD STRENGTH DATA  FOR THE LOW VHF PROPAGATION CURVE.  
!  ( FM AND TV CHANNELS 2 THROUGH 6 ) -- (13 points * 31 curves = 403)              
!**********************************************************************/
// Includes a derived Interfering curve (31) to smooth out the graph and interpolation 
// for the rarely used F(50,10) curve at 498.89644 km
// was [31][13] 

var F51LV = [52.2, 41.4, 36.4, 33.0, 30.0, 26.7, 23.5, 20.4, 17.4, 14.5, 11.5, 8.5, 5.9, 3.0, 0.6, -2.0,
	-4.3, -6.6, -8.7, -10.5, -12.5, -14.6, -16.6, -18.6, -20.5, -22.4, -24.3, -26.2, -28.1, -30.0,
	-31.9, 58.4, 47.0, 40.9, 36.0, 31.9, 28.0, 24.9, 22.0, 19.0, 16.1, 13.1, 10.1, 7.7, 4.9, 2.0,
	-0.4, -3.0, -5.1, -7.4, -9.4, -11.4, -13.4, -15.5, -17.4, -19.3, -21.2, -23.2, -25.0, -27.0,
	-29.0, -31.0, 64.3, 53.0, 45.9, 39.9, 35.0, 30.5, 26.9, 24.0, 20.9, 18.2, 15.3, 12.4, 9.8, 6.9,
	4.1, 1.6, -1.0, -3.4, -5.8, -8.0, -10.1, -12.0, -14.1, -16.0, -18.0, -19.9, -21.9, -23.7, -25.6,
	-27.4, -29.2, 68.0, 56.5, 49.0, 43.0, 37.7, 32.8, 28.8, 25.6, 22.5, 19.8, 16.9, 13.9, 11.0, 8.2,
	5.7, 2.9, 0.3, -2.2, -4.6, -6.9, -9.0, -11.0, -13.0, -15.0, -17.0, -18.9, -20.9, -22.5, -24.6,
	-26.3, -28.0, 70.5, 59.0, 51.7, 45.4, 40.0, 34.9, 30.4, 27.0, 23.9, 21.0, 18.2, 15.1, 12.3, 9.7,
	6.9, 4.1, 1.6, -1.0, -3.4, -5.7, -8.0, -10.0, -12.0, -14.0, -16.0, -17.9, -19.9, -21.7, -23.6,
	-25.4, -27.2, 72.3, 60.9, 53.7, 47.5, 41.9, 36.8, 32.0, 28.4, 25.0, 22.0, 19.2, 16.2, 13.4, 10.7,
	8.0, 5.3, 2.7, 0.0, -2.5, -4.9, -7.0, -9.0, -11.2, -13.2, -15.1, -17.0, -19.0, -21.0, -23.0, -24.6,
	-26.2, 74.2, 63.0, 56.0, 50.0, 44.4, 39.2, 34.9, 30.8, 27.0, 23.9, 20.8, 17.8, 14.8, 12.0, 9.1,
	6.7, 3.9, 1.1, -1.4, -3.9, -6.0, -8.0, -10.2, -12.2, -14.2, -16.2, -18.1, -20.0, -22.0, -23.7,
	-25.4, 75.9, 64.8, 57.9, 52.0, 46.7, 41.6, 37.1, 33.0, 29.0, 25.5, 22.0, 19.0, 16.0, 13.2, 10.3,
	7.9, 5.0, 2.2, -0.2, -2.8, -5.0, -7.0, -9.2, -11.3, -13.3, -15.3, -17.2, -19.2, -21.1, -22.8,
	-24.5, 77.0, 66.2, 59.6, 54.0, 48.5, 43.5, 39.2, 35.0, 30.8, 26.9, 23.2, 20.0, 17.1, 14.2, 11.6,
	9.0, 6.0, 3.3, 0.9, -1.8, -4.0, -6.2, -8.2, -10.5, -12.5, -14.6, -16.3, -18.4, -20.2, -22.0, -23.8,
	78.2, 67.6, 60.9, 55.2, 50.0, 45.0, 40.7, 36.2, 32.0, 28.0, 24.1, 21.0, 18.0, 15.3, 12.5, 10.0, 7.0,
	4.4, 1.8, -0.8, -3.0, -5.3, -7.4, -9.8, -11.8, -14.0, -15.8, -17.8, -19.6, -21.3, -23.0, 80.8,
	71.2, 64.5, 58.9, 53.9, 49.0, 44.2, 39.8, 35.4, 31.3, 27.6, 24.4, 21.6, 18.9, 16.0, 13.6, 10.7, 8.0,
	5.2, 2.8, 0.3, -2.0, -4.5, -7.0, -9.0, -11.1, -13.2, -15.0, -17.0, -19.0, -21.0, 81.8, 73.8, 67.0,
	61.4, 56.3, 51.7, 46.9, 42.0, 37.8, 33.8, 30.0, 27.0, 24.1, 21.5, 18.8, 16.1, 13.6, 10.9, 8.1, 5.3,
	3.0, 0.4, -1.9, -4.3, -6.7, -9.0, -11.0, -12.9, -14.9, -16.9, -18.9, 82.2, 75.5, 69.0, 63.3, 58.4,
	53.5, 48.8, 44.0, 39.7, 35.7, 32.1, 29.1, 26.1, 23.5, 20.9, 18.0, 15.7, 13.0, 10.2, 7.5, 5.0, 2.6,
	0.0, -2.4, -4.6, -6.9, -9.0, -11.0, -13.0, -15.0, -17.0];


/***********************************************************************
!  F(50,50) FIELD STRENGTH DATA FOR THE HIGH VHF PROPAGATION CURVE  
!  ( TV CHANNELS 7 THROUGH 13 ) -- (13 points * 25 rows = 325) 
!*********************************************************************/
// was [25][13] 


var F55HV = [94.6, 82.8, 75.7, 70.7, 66.8, 55.0, 42.5, 34.0, 26.3, 20.7, 16.3, 12.9, 9.9, 7.0, 4.3, 1.5,
	-1.0, -3.5, -5.7, -8.0, -10.4, -12.8, -15.0, -17.2, -19.1, 100.7, 88.9, 81.8, 76.9, 73.0, 61.0,
	48.6, 40.0, 32.0, 24.1, 18.5, 14.4, 11.2, 8.3, 5.5, 2.9, 0.5, -2.0, -4.3, -6.9, -9.2, -11.5,
	-13.8, -16.0, -18.2, 101.6, 92.3, 86.6, 82.2, 78.8, 67.2, 54.7, 46.1, 38.1, 30.1, 23.0, 17.0,
	13.5, 10.5, 7.5, 4.8, 2.3, -0.3, -2.7, -5.0, -7.3, -9.8, -12.0, -14.4, -16.8, 101.8, 93.9,
	88.7, 84.8, 81.6, 70.8, 58.1, 49.8, 41.7, 33.8, 26.2, 20.0, 15.2, 12.0, 9.0, 6.2, 3.7, 1.0,
	-1.2, -3.7, -6.0, -8.4, -10.7, -13.0, -15.5, 101.9, 94.6, 89.8, 86.2, 83.2, 73.2, 60.7, 52.1,
	44.0, 36.1, 28.8, 22.1, 17.0, 13.7, 10.4, 7.5, 4.8, 2.2, -0.1, -2.5, -4.9, -7.3, -9.7, -12.0,
	-14.4, 102.0, 95.0, 90.5, 87.0, 84.5, 75.0, 62.5, 54.2, 46.0, 38.0, 30.6, 24.0, 18.9, 15.0,
	11.5, 8.6, 5.8, 3.2, 0.9, -1.5, -4.0, -6.3, -8.7, -11.0, -13.4, 102.3, 95.4, 91.3, 88.0, 85.7,
	77.0, 65.0, 56.7, 48.8, 40.9, 33.5, 26.8, 21.2, 17.0, 13.1, 10.0, 7.0, 4.4, 2.0, -0.5, -3.0,
	-5.3, -7.6, -10.0, -12.3, 102.3, 95.7, 91.8, 88.7, 86.3, 78.1, 67.6, 59.0, 51.0, 43.5, 36.3,
	29.6, 23.9, 19.0, 14.9, 11.2, 8.2, 5.5, 3.0, 0.6, -2.0, -4.3, -6.6, -9.0, -11.3, 102.3, 95.9,
	92.0, 89.1, 87.0, 79.1, 69.5, 61.0, 53.3, 46.0, 39.0, 32.0, 26.0, 21.0, 16.2, 12.7, 9.5, 6.5,
	4.0, 1.5, -1.0, -3.5, -5.8, -8.2, -10.5, 102.4, 96.0, 92.1, 89.5, 87.3, 80.0, 71.0, 62.8, 55.0,
	47.9, 41.0, 34.0, 28.0, 22.6, 17.5, 13.6, 10.5, 7.4, 4.9, 2.2, -0.2, -2.6, -5.0, -7.3, -9.8,
	102.4, 96.2, 92.6, 90.0, 88.0, 81.1, 73.9, 66.3, 58.7, 52.0, 45.0, 38.2, 32.0, 26.3, 21.1,
	17.0, 14.0, 10.7, 8.0, 5.6, 3.0, 0.6, -1.8, -4.2, -6.6, 102.4, 96.2, 92.6, 90.0, 88.0, 81.8,
	74.8, 67.4, 60.3, 53.8, 47.0, 40.6, 34.4, 28.8, 23.8, 19.8, 16.6, 13.1, 10.4, 8.2, 5.5, 3.1,
	0.9, -1.8, -4.0, 102.5, 96.5, 92.7, 90.1, 88.0, 82.0, 75.0, 68.0, 61.1, 54.6, 48.1, 42.0,
	36.1, 30.6, 25.5, 21.8, 18.5, 15.1, 12.3, 10.1, 7.5, 5.1, 2.9, 0.3, -1.9];



/***********************************************************************
!   F(50,10) FIELD STRENGTH DATA FOR THE HIGH VHF PROPAGATION CURVE  
!   ( TV CHANNELS 7 THROUGH 13 ) -- (13 points * 31 curves = 403)                     
!***********************************************************************/
// Includes a derived Interfering curve (31) to smooth out the graph and interpolation 
// for the rarely used F(50,10) curve at 498.89644 km
// was [31][13]  

var F51HV = [55.4, 44.4, 39.2, 34.0, 29.9, 26.6, 23.5, 20.3, 17.4, 14.3, 11.3, 8.6, 5.8, 2.9, 0.3,
	-2.1, -4.4, -6.7, -8.9, -10.8, -12.9, -14.8, -16.9, -18.8, -20.7, -22.7, -24.6, -26.4, -28.2,
	-30.1, -32.0, 61.6, 50.0, 43.5, 38.0, 32.5, 28.2, 25.0, 22.0, 19.0, 16.0, 13.0, 10.0, 7.2,
	4.7, 1.9, -0.7, -3.2, -5.4, -7.8, -9.8, -11.8, -13.8, -15.8, -17.7, -19.7, -21.4, -23.3,
	-25.2, -27.1, -29.0, -30.9, 67.7, 55.8, 48.6, 42.7, 35.9, 31.0, 27.0, 24.0, 21.0, 18.1, 15.1,
	12.2, 9.4, 6.8, 3.8, 1.2, -1.4, -3.8, -6.1, -8.2, -10.3, -12.3, -14.3, -16.3, -18.3, -20.1,
	-22.0, -24.0, -25.9, -27.7, -29.5, 71.0, 59.1, 52.0, 45.6, 38.8, 33.4, 28.9, 25.5, 22.4, 19.6,
	16.7, 13.7, 10.8, 8.1, 5.2, 2.7, 0.0, -2.3, -4.8, -7.0, -9.0, -11.1, -13.1, -15.1, -17.0,
	-19.0, -20.9, -22.9, -24.8, -26.5, -28.2, 73.5, 61.7, 54.6, 48.0, 41.0, 35.4, 30.7, 27.0,
	23.8, 20.8, 18.0, 15.0, 12.0, 9.5, 6.5, 3.9, 1.2, -1.2, -3.8, -6.0, -8.2, -10.2, -12.2,
	-14.2, -16.2, -18.0, -20.0, -21.9, -23.9, -25.5, -27.1, 75.3, 63.7, 56.5, 50.0, 43.0, 37.4,
	32.3, 28.3, 25.0, 22.0, 19.1, 16.3, 13.3, 10.6, 7.8, 5.0, 2.4, 0.0, -2.6, -5.0, -7.1, -9.3,
	-11.2, -13.3, -15.3, -17.2, -19.1, -21.0, -23.0, -24.9, -26.7, 77.1, 66.5, 59.0, 52.5, 45.8,
	40.0, 35.0, 30.4, 26.9, 23.5, 20.5, 17.6, 14.7, 12.0, 9.0, 6.4, 3.7, 1.0, -1.4, -4.0, -6.0,
	-8.2, -10.2, -12.3, -14.3, -16.2, -18.2, -20.0, -22.0, -23.9, -25.8, 78.6, 68.9, 61.5, 54.9,
	48.2, 43.0, 37.4, 32.9, 28.8, 25.0, 22.0, 18.8, 15.9, 13.0, 10.3, 7.5, 4.9, 2.1, -0.3, -3.0,
	-5.1, -7.4, -9.4, -11.4, -13.5, -15.4, -17.4, -19.2, -21.1, -23.0, -24.9, 79.6, 70.8, 63.6,
	56.9, 50.8, 45.4, 40.0, 35.0, 30.4, 26.4, 23.0, 19.9, 17.0, 14.1, 11.5, 8.8, 6.0, 3.3, 0.8,
	-2.0, -4.2, -6.5, -8.6, -10.6, -12.8, -14.8, -16.8, -18.5, -20.3, -22.1, -23.9, 80.4, 72.0,
	65.2, 58.8, 53.0, 47.6, 42.0, 36.8, 32.0, 27.7, 24.0, 20.7, 18.0, 15.2, 12.5, 9.8, 7.0, 4.3,
	1.7, -1.0, -3.3, -5.6, -7.8, -9.8, -12.0, -14.0, -16.0, -18.0, -19.6, -21.5, -23.4, 82.0, 75.0,
	68.6, 62.5, 57.0, 52.0, 46.8, 41.5, 35.8, 31.0, 27.6, 24.0, 21.4, 18.8, 16.0, 13.1, 10.6, 7.9,
	5.0, 2.5, 0.0, -2.4, -4.7, -6.9, -9.0, -11.1, -13.1, -15.1, -17.0, -19.0, -21.0, 82.4, 75.9,
	69.8, 64.0, 58.9, 53.8, 48.9, 43.7, 38.2, 33.6, 30.0, 26.8, 24.0, 21.2, 18.7, 15.9, 13.2, 10.6,
	8.0, 5.2, 2.8, 0.2, -2.0, -4.3, -6.5, -9.0, -11.0, -13.0, -15.0, -16.8, -18.6, 82.5, 76.2, 70.2,
	64.9, 59.8, 54.8, 50.0, 45.0, 40.1, 35.5, 32.0, 28.9, 26.0, 23.4, 20.7, 18.0, 15.4, 12.8, 10.0,
	7.3, 4.9, 2.2, -0.1, -2.4, -4.7, -7.0, -9.0, -11.0, -13.0, -15.0, -17.0];

/***********************************************************************
!   F(50,50) FIELD STRENGTH DATA FOR THE UHF PROPAGATION CURVE 
!   ( TV CHANNELS 14 THROUGH 83 ) -- (13 points * 25 curves = 325)                          
!***********************************************************************/
// was [25][13]

var F55U = [92.0, 80.0, 72.9, 67.9, 63.8, 51.9, 39.0, 27.5, 17.8, 13.0, 10.1, 7.0, 4.2, 1.6, -1.0,
	-3.2, -5.0, -7.2, -9.1, -11.0, -13.1, -15.1, -17.2, -19.3, -21.4, 97.9, 86.0, 79.0, 74.0,
	70.0, 58.0, 45.2, 33.5, 22.7, 16.0, 11.7, 8.5, 5.5, 2.8, 0.2, -2.0, -4.2, -6.3, -8.4, -10.3,
	-12.3, -14.2, -16.2, -18.3, -20.1, 100.7, 91.0, 84.7, 80.0, 76.0, 64.0, 51.2, 39.6, 28.2,
	19.6, 14.4, 10.8, 7.7, 4.7, 1.9, -0.4, -2.7, -4.9, -7.0, -8.9, -10.9, -12.8, -14.8, -16.8,
	-18.7, 101.5, 93.0, 87.4, 83.3, 79.5, 67.6, 54.6, 43.0, 31.5, 22.3, 16.8, 12.5, 9.3, 6.0,
	3.2, 0.7, -1.5, -3.8, -5.9, -7.9, -9.9, -11.7, -13.8, -15.8, -17.7, 101.9, 94.1, 89.0, 85.1,
	81.5, 70.0, 57.2, 45.7, 34.5, 25.1, 19.1, 14.2, 10.8, 7.5, 4.6, 1.9, -0.4, -2.9, -5.0, -7.0,
	-9.0, -10.8, -12.8, -14.8, -16.8, 102.0, 94.8, 90.0, 86.3, 82.9, 72.0, 59.1, 48.0, 37.3, 28.3,
	21.7, 16.3, 12.4, 8.9, 5.7, 3.0, 0.5, -2.0, -4.2, -6.1, -8.0, -10.0, -11.9, -13.9, -15.9, 102.1,
	95.2, 90.8, 87.3, 84.1, 73.8, 61.0, 50.5, 40.3, 31.8, 24.7, 19.0, 14.5, 10.6, 7.1, 4.3, 1.7,
	-0.9, -3.2, -5.2, -7.1, -9.0, -11.0, -13.0, -15.0, 102.2, 95.6, 91.3, 88.0, 85.0, 75.3, 62.6, 52.3,
	42.7, 34.1, 27.0, 21.3, 16.3, 12.0, 8.5, 5.6, 2.8, 0.0, -2.3, -4.3, -6.2, -8.2, -10.2, -12.2,
	-14.1, 102.3, 95.9, 91.8, 88.6, 85.8, 76.5, 64.0, 53.9, 44.3, 36.0, 29.3, 23.4, 18.0, 13.6, 9.7,
	6.7, 3.8, 1.0, -1.6, -3.6, -5.5, -7.5, -9.5, -11.4, -13.2, 102.4, 96.0, 92.0, 88.9, 86.2, 77.2,
	65.0, 55.0, 45.7, 37.6, 31.0, 25.0, 19.8, 15.0, 10.8, 7.7, 4.8, 1.9, -0.9, -3.0, -4.8, -6.8, -8.9,
	-10.8, -12.5, 102.5, 96.3, 92.5, 89.6, 87.3, 79.6, 68.2, 58.4, 49.4, 41.7, 35.4, 29.8, 24.5, 19.8,
	15.0, 11.5, 8.2, 5.0, 2.0, -0.2, -2.2, -4.3, -6.3, -8.3, -10.0, 102.5, 96.5, 92.8, 90.0, 87.9,
	80.5, 70.0, 60.8, 52.1, 44.8, 38.6, 33.0, 28.0, 23.4, 18.8, 14.8, 11.1, 7.8, 4.6, 1.9, -0.1,
	-2.2, -4.2, -6.1, -8.0, 102.5, 96.5, 93.0, 90.3, 88.1, 81.0, 71.1, 62.5, 54.0, 46.7, 41.0, 35.7,
	30.8, 26.0, 21.8, 17.5, 13.7, 10.0, 6.7, 3.7, 1.7, -0.4, -2.3, -4.4, -6.3];

/***********************************************************************
!   F(50,10) FIELD STRENGTH DATA FOR THE UHF PROPAGATION CURVE 
!   ( TV CHANNELS 14 THROUGH 83 )  - (13 points * 31 curves = 403)                          
!***********************************************************************/
// Includes a derived Interfering curve (31) to smooth out the graph and interpolation for the 
// rarely used F(50,10) curve at 498.89644 km
// was [31][13]  

var F51U = [52.2, 41.6, 35.0, 30.3, 27.0, 23.8, 20.8, 17.8, 14.8, 12.0, 9.2, 6.6, 4.0, 1.2, -1.3,
	-3.8, -6.0, -8.4, -10.3, -12.5, -14.5, -16.5, -18.5, -20.5, -22.4, -24.2, -26.0, -27.8,
	-29.5, -31.0, -32.5, 58.3, 46.7, 38.0, 32.1, 28.3, 25.2, 22.2, 19.3, 16.5, 13.4, 10.7, 8.0,
	5.1, 2.5, -0.2, -2.4, -4.9, -7.2, -9.3, -11.3, -13.5, -15.5, -17.4, -19.3, -21.3, -23.2,
	-25.0, -27.0, -28.5, -30.1, -31.6, 64.7, 52.4, 43.0, 35.3, 30.8, 27.6, 24.5, 21.3, 18.5,
	15.6, 12.7, 9.9, 7.1, 4.4, 1.8, -0.8, -3.1, -5.5, -7.7, -9.8, -12.0, -14.0, -15.9, -17.8,
	-19.8, -21.6, -23.4, -25.5, -27.1, -28.9, -30.7, 68.0, 56.0, 46.3, 37.6, 32.6, 29.1, 26.0,
	23.0, 20.0, 17.1, 14.0, 11.2, 8.8, 6.0, 3.2, 0.8, -1.7, -4.1, -6.2, -8.4, -10.4, -12.7,
	-14.6, -16.5, -18.6, -20.4, -22.2, -24.2, -26.0, -27.9, -29.8, 70.5, 58.5, 48.8, 40.0, 34.7,
	30.4, 27.2, 24.2, 21.2, 18.3, 15.2, 12.6, 10.0, 7.3, 4.6, 1.9, -0.5, -3.0, -5.2, -7.4,
	-9.6, -11.7, -13.8, -15.6, -17.7, -19.6, -21.3, -23.3, -25.0, -27.0, -29.0, 72.3, 60.3,
	50.8, 42.4, 36.7, 32.0, 28.4, 25.4, 22.4, 19.7, 16.5, 13.8, 11.0, 8.3, 5.7, 3.0, 0.6,
	-2.0, -4.3, -6.6, -8.8, -10.8, -13.0, -14.9, -17.0, -18.9, -20.8, -22.7, -24.4, -26.3,
	-28.2, 74.1, 62.3, 52.9, 45.1, 39.0, 34.5, 30.4, 27.0, 23.9, 21.0, 18.0, 15.3, 12.5, 9.7,
	7.0, 4.4, 1.8, -0.7, -3.2, -5.4, -7.7, -9.8, -12.0, -14.0, -16.0, -17.9, -19.9, -21.8,
	-23.7, -25.6, -27.5, 75.4, 63.9, 54.9, 47.1, 40.8, 36.4, 32.2, 28.8, 25.2, 22.1, 19.3, 16.4,
	13.8, 10.9, 8.1, 5.6, 2.9, 0.3, -2.2, -4.5, -6.7, -8.9, -11.0, -13.0, -15.0, -17.0, -19.1,
	-21.0, -22.8, -24.8, -26.8, 76.4, 65.2, 56.3, 48.7, 42.4, 37.9, 33.9, 30.2, 26.6, 23.4, 20.3,
	17.3, 14.8, 11.9, 9.1, 6.7, 3.9, 1.3, -1.2, -3.6, -5.8, -7.9, -10.0, -12.2, -14.2, -16.2,
	-18.2, -20.2, -22.0, -24.0, -26.0, 77.4, 66.2, 57.6, 50.0, 43.7, 39.0, 35.1, 31.7, 27.8,
	24.6, 21.3, 18.3, 15.7, 12.8, 10.0, 7.6, 4.8, 2.1, -0.4, -2.8, -5.0, -7.1, -9.2, -11.3,
	-13.4, -15.4, -17.5, -19.4, -21.3, -23.2, -25.1, 79.5, 69.3, 60.9, 53.6, 47.7, 43.1, 39.2,
	35.8, 32.0, 28.3, 24.9, 21.7, 18.8, 15.9, 13.1, 10.6, 7.9, 5.1, 2.2, 0.0, -2.2, -4.3, -6.6,
	-8.9, -11.0, -13.0, -15.0, -17.0, -19.0, -21.0, -22.9, 80.7, 71.2, 63.0, 56.1, 50.2, 46.0,
	42.1, 38.7, 35.0, 31.3, 27.8, 24.3, 21.2, 18.2, 15.5, 12.8, 10.0, 7.3, 4.7, 2.1, 0.0, -2.2,
	-4.6, -6.8, -8.8, -10.8, -12.9, -14.9, -16.9, -18.9, -20.9, 81.3, 72.6, 64.5, 58.0, 52.4,
	48.0, 44.3, 40.7, 37.3, 33.8, 30.3, 27.0, 23.7, 20.5, 17.4, 14.7, 12.0, 9.2, 6.5, 4.0, 1.8,
	-0.4, -2.8, -5.0, -7.0, -9.0, -11.0, -13.0, -15.0, -16.8, -18.6];

/*  TVFMFS:  DATA TABLE INITIALIZATION OK, CONTINUE WITH PROGRAM   */

// ========The following data is needed for fzq to calculate F(50,90) or other curves ================//

var VGRID = [0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5,
	0.6, 0.7, 0.8, 0.9, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0,
	11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 22.0, 24.0, 26.0, 28.0, 30.0,
	32.0, 34.0, 36.0, 38.0, 40.0, 42.0, 44.0, 46.0, 48.0, 50.0, 52.0, 54.0, 56.0, 58.0, 60.0,
	62.0, 64.0, 66.0, 68.0, 70.0, 72.0, 74.0, 76.0, 78.0, 80.0, 81.0, 82.0, 83.0, 84.0, 85.0,
	86.0, 87.0, 88.0, 89.0, 90.0, 91.0, 92.0, 93.0, 94.0, 95.0, 96.0, 97.0, 98.0, 98.2, 98.4,
	98.6, 98.8, 99.0, 99.1, 99.2, 99.3, 99.4, 99.5, 99.6, 99.7, 99.8, 99.85, 99.9, 99.91, 99.92,
	99.93, 99.94, 99.95, 99.96, 99.97, 99.98, 99.99];

var ZGRI = [-3.71902, -3.54008, -3.43161, -3.35279, -3.29053, -3.23888, -3.19465, -3.15591, -3.12139,
-3.09023, -2.96774, -2.87816, -2.74778, -2.65207, -2.57583, -2.51214, -2.45726, -2.40892,
-2.36562, -2.32635, -2.25713, -2.19729, -2.14441, -2.09693, -2.05375, -1.88079, -1.75069,
-1.64485, -1.55477, -1.47579, -1.40507, -1.34076, -1.28155, -1.22653, -1.17499, -1.12639,
-1.08032, -1.03643, -0.99446, -0.95416, -0.91537, -0.8779, -0.84162, -0.77219, -0.7063,
-0.64335, -0.58284, -0.5244, -0.4677, -0.41246, -0.35846, -0.30548, -0.25335, -0.20189,
-0.15097, -0.10043, -0.05015];


/*
//------- ITPLBV --------------------------------------------------------------------------------------------------
// Interpolation subroutine, this is a bi-variate surface fitting procedure, refer to the original FCC CURVES program
// and to the paper referenced in comments above for details.  Sorry about the shortage of comments, but there were
// none in the original source.

// This has been modified from the original, taking into account the context in which it is being used.  It was a full
// general-purpose routine, however many of the conditions that had exception-handling could never have occurred given
// the limited range of possible values in context.  Much of that unnecessary code has been eliminated.

// Arguments:

//    lx  Number of columns in table.
//    ly  Number of rows in table.
//    x   Column enumeration values.
//    y   Row enumeration values.
//    z   Data table.
//    n   Number of points to lookup.
//    u   Column values for lookup points.
//    v   Row values for lookup points.
//    w   Return result of lookups.
*/


function itplbv(lx, ly, x, y, z, n, u, v, w) {
	// declarations and initializations


	var lxm1, lxp1, lym1, lyp1, ixpv, iypv, k, ix, iy, imn, imx, jx, jy, jx1, jy1;
	lxm1 = lxp1 = lym1 = lyp1 = ixpv = iypv = k = ix = iy = imn = imx = jx = jy = jx1 = jy1 = 0;

	var za_row0 = [0, 0];
	var za_row1 = [0, 0];
	var za_row2 = [0, 0];
	var za_row3 = [0, 0];
	var za_row4 = [0, 0];
	var za = [za_row0, za_row1, za_row2, za_row3, za_row4];   // za[5,2]

	var zb_row0 = [0, 0, 0, 0, 0];
	var zb_row1 = [0, 0, 0, 0, 0];
	var zb = [zb_row0, zb_row1];                              // zb[2,5]

	var zab_row0 = [0, 0, 0];
	var zab_row1 = [0, 0, 0];
	var zab_row2 = [0, 0, 0];
	var zab = [zab_row0, zab_row1, zab_row2];                  // zab[3,3]

	var zx_row0 = [0, 0, 0, 0];
	var zx_row1 = [0, 0, 0, 0];
	var zx_row2 = [0, 0, 0, 0];
	var zx_row3 = [0, 0, 0, 0];
	var zx = [zx_row0, zx_row1, zx_row2, zx_row3];            // zx[4,4]

	var zy_row0 = [0, 0, 0, 0];
	var zy_row1 = [0, 0, 0, 0];
	var zy_row2 = [0, 0, 0, 0];
	var zy_row3 = [0, 0, 0, 0];
	var zy = [zy_row0, zy_row1, zy_row2, zy_row3];            // zy[4,4]  

	var zxy_row0 = [0, 0, 0, 0];
	var zxy_row1 = [0, 0, 0, 0];
	var zxy_row2 = [0, 0, 0, 0];
	var zxy_row3 = [0, 0, 0, 0];
	var zxy = [zxy_row0, zxy_row1, zxy_row2, zxy_row3];        // zy[4,4]  


	var x3, x4, a3, y3, y4, b3, z33, z43, z34, z44, x2, a2, z23, z24, x5, a4, z53, z54;
	x3 = x4 = a3 = y3 = y4 = b3 = z33 = z43 = z34 = z44 = x2 = a2 = z23 = z24 = x5 = a4 = z53 = z54 = 0.0;

	var a1, a5, y2, b2, z32, z42, y5, b4, z35, z45, b1, b5, w2, w3, sw, wx2, wx3, wy2, wy3, w1, w4, w5;
	a1 = a5 = y2 = b2 = z32 = z42 = y5 = b4 = z35 = z45 = b1 = b5 = w2 = w3 = sw = wx2 = wx3 = wy2 = wy3 = w1 = w4 = w5 = 0.0;

	var zx3b3, zx4b3, zy3a3, zy4a3, a, b, c, d, e, a3sq, b3sq, p02, p03, p12, p13, p20, p21, p22;
	zx3b3 = zx4b3 = zy3a3 = zy4a3 = a = b = c = d = e = a3sq = b3sq = p02 = p03 = p12 = p13 = p20 = p21 = p22 = 0.0;

	var p23, p30, p31, p32, p33, dy, q0, q1, q2, q3, dx;
	p23 = p30 = p31 = p32 = p33 = dy = q0 = q1 = q2 = q3 = dx = 0.0;




	// Calculations begin 


	lx = Math.floor(lx);
	ly = Math.floor(ly);


	lxm1 = Math.floor(lx - 1);
	lxp1 = Math.floor(lx + 1);
	lym1 = Math.floor(ly - 1);
	lyp1 = Math.floor(ly + 1);
	ixpv = -1;
	iypv = -1;
	for (k = 0; k < n; k++) {
		if (u[k] >= x[lxm1]) {
			ix = lx;
		} else {
			if (u[k] < x[0]) {
				ix = 0;
			} else {
				imn = 1;
				imx = lxm1;
				do {
					ix = Math.floor((imn + imx) / 2);
					if (u[k] >= x[ix]) {
						imn = ix + 1;
					} else {
						imx = ix;
					}
				} while (imx > imn);
				ix = imx;
			}
		}
		ix = Math.floor(ix);

		if (v[k] >= y[lym1]) {
			iy = ly;
		} else {
			if (v[k] < y[0]) {
				iy = 0;
			} else {
				imn = 1;
				imx = lym1;
				do {
					iy = Math.floor((imn + imx) / 2);
					if (v[k] >= y[iy]) {
						imn = iy + 1;
					} else {
						imx = iy;
					}
				} while (imx > imn);
				iy = imx;
			}
		}
		iy = Math.floor(iy);

		if ((ix !== ixpv) || (iy !== iypv)) {
			ixpv = ix;
			iypv = iy;
			if (ix === 0) {
				jx = 1;
			} else {
				if (ix === lx) {
					jx = lxm1;
				} else {
					jx = ix;
				}
			}
			if (iy === 0) {
				jy = 1;
			} else {
				if (iy === ly) {
					jy = lym1;
				} else {
					jy = iy;
				}
			}
			jx = Math.floor(jx);
			jy = Math.floor(jy);

			x3 = x[jx - 1];
			x4 = x[jx];
			a3 = 1.0 / (x4 - x3);
			y3 = y[jy - 1];
			y4 = y[jy];
			b3 = 1.0 / (y4 - y3);
			z33 = z[(jx - 1) + ((jy - 1) * lx)];
			z43 = z[jx + ((jy - 1) * lx)];
			z34 = z[(jx - 1) + (jy * lx)];
			z44 = z[jx + (jy * lx)];
			za[2][0] = (z43 - z33) * a3;
			za[2][1] = (z44 - z34) * a3;
			zb[0][2] = (z34 - z33) * b3;
			zb[1][2] = (z44 - z43) * b3;
			zab[1][1] = (zb[1][2] - zb[0][2]) * a3;
			if (jx > 1) {
				x2 = x[jx - 2];
				a2 = 1.0 / (x3 - x2);
				z23 = z[(jx - 2) + ((jy - 1) * lx)];
				z24 = z[(jx - 2) + (jy * lx)];
				za[1][0] = (z33 - z23) * a2;
				za[1][1] = (z34 - z24) * a2;
				if (jx === lxm1) {
					za[3][0] = (2.0 * za[2][0]) - za[1][0];
					za[3][1] = (2.0 * za[2][1]) - za[1][1];
				}
			}

			if (jx < lxm1) {
				x5 = x[jx + 1];
				a4 = 1.0 / (x5 - x4);
				z53 = z[(jx + 1) + ((jy - 1) * lx)];
				z54 = z[(jx + 1) + (jy * lx)];
				za[3][0] = (z53 - z43) * a4;
				za[3][1] = (z54 - z44) * a4;
				if (jx === 1) {
					za[1][0] = (2.0 * za[2][0]) - za[3][0];
					za[1][1] = (2.0 * za[2][1]) - za[3][1];
				}
			}

			zab[0][1] = (za[1][1] - za[1][0]) * b3;
			zab[2][1] = (za[3][1] - za[3][0]) * b3;
			if (jx > 2) {
				a1 = 1.0 / (x2 - x[jx - 3]);
				za[0][0] = (z23 - z[(jx - 3) + ((jy - 1) * lx)]) * a1;
				za[0][1] = (z24 - z[(jx - 3) + (jy * lx)]) * a1;
			} else {
				za[0][0] = (2.0 * za[1][0]) - za[2][0];
				za[0][1] = (2.0 * za[1][1]) - za[2][1];
			}
			if (jx < (lx - 2)) {
				a5 = 1.0 / (x[jx + 2] - x5);
				za[4][0] = (z[(jx + 2) + ((jy - 1) * lx)] - z53) * a5;
				za[4][1] = (z[(jx + 2) + (jy * lx)] - z54) * a5;
			} else {
				za[4][0] = (2.0 * za[3][0]) - za[2][0];
				za[4][1] = (2.0 * za[3][1]) - za[2][1];
			}
			if (jy > 1) {
				y2 = y[jy - 2];
				b2 = 1.0 / (y3 - y2);
				z32 = z[(jx - 1) + ((jy - 2) * lx)];
				z42 = z[jx + ((jy - 2) * lx)];
				zb[0][1] = (z33 - z32) * b2;
				zb[1][1] = (z43 - z42) * b2;
				if (jy === lym1) {
					zb[0][3] = (2.0 * zb[0][2]) - zb[0][1];
					zb[1][3] = (2.0 * zb[1][2]) - zb[1][1];
				}
			}
			if (jy < lym1) {
				y5 = y[jy + 1];
				b4 = 1.0 / (y5 - y4);
				z35 = z[(jx - 1) + ((jy + 1) * lx)];
				z45 = z[jx + ((jy + 1) * lx)];
				zb[0][3] = (z35 - z34) * b4;
				zb[1][3] = (z45 - z44) * b4;
				if (jy === 1) {
					zb[0][1] = (2.0 * zb[0][2]) - zb[0][3];
					zb[1][1] = (2.0 * zb[1][2]) - zb[1][3];
				}
			}
			zab[1][0] = (zb[1][1] - zb[0][1]) * a3;
			zab[1][2] = (zb[1][3] - zb[0][3]) * a3;
			if (jy > 2) {
				b1 = 1.0 / (y2 - y[jy - 3]);
				zb[0][0] = (z32 - z[(jx - 1) + ((jy - 3) * lx)]) * b1;
				zb[1][0] = (z42 - z[jx + ((jy - 3) * lx)]) * b1;
			} else {
				zb[0][0] = (2.0 * zb[0][1]) - zb[0][2];
				zb[1][0] = (2.0 * zb[1][1]) - zb[1][2];
			}
			if (jy < (ly - 2)) {
				b5 = 1.0 / (y[jy + 2] - y5);
				zb[0][4] = (z[(jx - 1) + ((jy + 2) * lx)] - z35) * b5;
				zb[1][4] = (z[jx + ((jy + 2) * lx)] - z45) * b5;
			} else {
				zb[0][4] = (2.0 * zb[0][3]) - zb[0][2];
				zb[1][4] = (2.0 * zb[1][3]) - zb[1][2];
			}
			if (jx < lxm1) {
				if (jy > 1) {
					zab[2][0] = ((z53 - z[(jx + 1) + ((jy - 2) * lx)]) * b2 - zb[1][1]) * a4;
					if (jy < lym1) {
						zab[2][2] = ((z[(jx + 1) + ((jy + 1) * lx)] - z54) * b4 - zb[1][3]) * a4;
					} else {
						zab[2][2] = (2.0 * zab[2][1]) - zab[2][0];
					}
				} else {
					zab[2][2] = ((z[(jx + 1) + ((jy + 1) * lx)] - z54) * b4 - zb[1][3]) * a4;
					zab[2][0] = (2.0 * zab[2][1]) - zab[2][2];
				}
				if (jx === 1) {
					zab[0][0] = (2.0 * zab[1][0]) - zab[2][0];
					zab[0][2] = (2.0 * zab[1][2]) - zab[2][2];
				}
			}
			if (jx > 1) {
				if (jy > 1) {
					zab[0][0] = (zb[0][1] - (z23 - z[(jx - 2) + ((jy - 2) * lx)]) * b2) * a2;
					if (jy < lym1) {
						zab[0][2] = (zb[0][3] - (z[(jx - 2) + ((jy + 1) * lx)] - z24) * b4) * a2;
					} else {
						zab[0][2] = (2.0 * zab[0][1]) - zab[0][0];
					}
				} else {
					zab[0][2] = (zb[0][3] - (z[(jx - 2) + ((jy + 1) * lx)] - z24) * b4) * a2;
					zab[0][0] = (2.0 * zab[0][1]) - zab[0][2];
				}
				if (jx === lxm1) {
					zab[2][0] = (2.0 * zab[1][0]) - zab[0][0];
					zab[2][2] = (2.0 * zab[1][2]) - zab[0][2];
				}
			}
			for (jy = 1; jy < 3; jy++) {
				for (jx = 1; jx < 3; jx++) {
					w2 = Math.abs(za[jx + 2][jy - 1] - za[jx + 1][jy - 1]);
					w3 = Math.abs(za[jx][jy - 1] - za[jx - 1][jy - 1]);
					sw = w2 + w3;
					if (sw >= 1.e-7) {
						wx2 = w2 / sw;
						wx3 = w3 / sw;
					} else {
						wx2 = 0.5;
						wx3 = 0.5;
					}
					zx[jx][jy] = wx2 * za[jx][jy - 1] + wx3 * za[jx + 1][jy - 1];
					w2 = Math.abs(zb[jx - 1][jy + 2] - zb[jx - 1][jy + 1]);
					w3 = Math.abs(zb[jx - 1][jy] - zb[jx - 1][jy - 1]);
					sw = w2 + w3;
					if (sw >= 1.e-7) {
						wy2 = w2 / sw;
						wy3 = w3 / sw;
					} else {
						wy2 = 0.5;
						wy3 = 0.5;
					}
					zy[jx][jy] = wy2 * zb[jx - 1][jy] + wy3 * zb[jx - 1][jy + 1];
					zxy[jx][jy] = wy2 * (wx2 * zab[jx - 1][jy - 1] + wx3 * zab[jx][jy - 1]) +
						wy3 * (wx2 * zab[jx - 1][jy] + wx3 * zab[jx][jy]);
				}
			}
			if (ix === 0) {
				w2 = a4 * (3.0 * a3 + a4);
				w1 = 2.0 * a3 * (a3 - a4) + w2;
				for (jy = 1; jy < 3; jy++) {
					zx[0][jy] = (w1 * za[0][jy - 1] + w2 * za[1][jy - 1]) / (w1 + w2);
					zy[0][jy] = (2.0 * zy[1][jy]) - zy[2][jy];
					zxy[0][jy] = (2.0 * zxy[1][jy]) - zxy[2][jy];
					for (jx1 = 1; jx1 < 3; jx1++) {
						jx = 3 - jx1;
						zx[jx][jy] = zx[jx - 1][jy];
						zy[jx][jy] = zy[jx - 1][jy];
						zxy[jx][jy] = zxy[jx - 1][jy];
					}
				}
				x3 -= 1.0 / a4;
				z33 -= za[1][0] / a4;
				for (jy = 0; jy < 5; jy++) {
					zb[1][jy] = zb[0][jy];
				}
				for (jy = 1; jy < 4; jy++) {
					zb[0][jy] -= zab[0][jy - 1] / a4;
				}
				a3 = a4;
				za[2][0] = za[1][0];
				for (jy = 0; jy < 3; jy++) {
					zab[1][jy] = zab[0][jy];
				}
			}
			if (ix === lx) {
				w4 = a2 * (3.0 * a3 + a2);
				w5 = 2.0 * a3 * (a3 - a2) + w4;
				for (jy = 1; jy < 3; jy++) {
					zx[3][jy] = (w4 * za[3][jy - 1] + w5 * za[4][jy - 1]) / (w4 + w5);
					zy[3][jy] = (2.0 * zy[2][jy]) - zy[1][jy];
					zxy[3][jy] = (2.0 * zxy[2][jy]) - zxy[1][jy];
					for (jx = 1; jx < 3; jx++) {
						zx[jx][jy] = zx[jx + 1][jy];
						zy[jx][jy] = zy[jx + 1][jy];
						zxy[jx][jy] = zxy[jx + 1][jy];
					}
				}
				x3 = x4;
				z33 = z43;
				for (jy = 0; jy < 5; jy++) {
					zb[0][jy] = zb[1][jy];
				}
				a3 = a2;
				za[2][0] = za[3][0];
				for (jy = 0; jy < 3; jy++) {
					zab[1][jy] = zab[2][jy];
				}
			}
			if (iy === 0) {
				w2 = b4 * (3.0 * b3 + b4);
				w1 = 2.0 * b3 * (b3 - b4) + w2;
				for (jx = 1; jx < 3; jx++) {
					if (((ix > 0) || (jx === 2)) && ((ix < lx) || (jx === 1))) {
						zy[jx][0] = (w1 * zb[jx - 1][0] + w2 * zb[jx - 1][1]) / (w1 + w2);
						zx[jx][0] = (2.0 * zx[jx][1]) - zx[jx][2];
						zxy[jx][0] = (2.0 * zxy[jx][1]) - zxy[jx][2];
					}
					for (jy1 = 1; jy1 < 3; jy1++) {
						jy = 3 - jy1;
						zy[jx][jy] = zy[jx][jy - 1];
						zx[jx][jy] = zx[jx][jy - 1];
						zxy[jx][jy] = zxy[jx][jy - 1];
					}
				}
				y3 -= 1.0 / b4;
				z33 -= zb[0][1] / b4;
				za[2][0] -= zab[1][0] / b4;
				zb[0][2] = zb[0][1];
				zab[1][1] = zab[1][0];
				b3 = b4;
				if ((ix === 0) || (ix === lx)) {
					if (ix === 0) {
						jx = 1;
						jx1 = 2;
					} else {
						jx = 2;
						jx1 = 1;
					}
					jx1 = Math.floor(jx1);
					zx[jx][1] = zx[jx1][1] + zx[jx][2] - zx[jx1][2];
					zy[jx][1] = zy[jx1][1] + zy[jx][2] - zy[jx1][2];
					zxy[jx][1] = zxy[jx1][1] + zxy[jx][2] - zxy[jx1][2];
				}
			}
			if (iy === ly) {
				w4 = b2 * (3.0 * b3 + b2);
				w5 = 2.0 * b3 * (b3 - b2) + w4;
				for (jx = 1; jx < 3; jx++) {
					if (((ix > 0) || (jx === 2)) && ((ix < lx) || (jx === 1))) {
						zy[jx][3] = (w4 * zb[jx - 1][3] + w5 * zb[jx - 1][4]) / (w4 + w5);
						zx[jx][3] = (2.0 * zx[jx][2]) - zx[jx][1];
						zxy[jx][3] = (2.0 * zxy[jx][2]) - zxy[jx][1];
					}
					for (jy = 1; jy < 3; jy++) {
						zy[jx][jy] = zy[jx][jy + 1];
						zx[jx][jy] = zx[jx][jy + 1];
						zxy[jx][jy] = zxy[jx][jy + 1];
					}
				}
				y3 = y4;
				z33 += zb[0][2] / b3;
				za[2][0] += zab[1][1] / b3;
				zb[0][2] = zb[0][3];
				zab[1][1] = zab[1][2];
				b3 = b2;
				if ((ix === 0) || (ix === lx)) {
					if (ix === 0) {
						jx = 1;
						jx1 = 2;
					} else {
						jx = 2;
						jx1 = 1;
					}
					zx[jx][2] = zx[jx1][2] + zx[jx][1] - zx[jx1][1];
					zy[jx][2] = zy[jx1][2] + zy[jx][1] - zy[jx1][1];
					zxy[jx][2] = zxy[jx1][2] + zxy[jx][1] - zxy[jx1][1];
				}
			}
			zx3b3 = (zx[1][2] - zx[1][1]) * b3;
			zx4b3 = (zx[2][2] - zx[2][1]) * b3;
			zy3a3 = (zy[2][1] - zy[1][1]) * a3;
			zy4a3 = (zy[2][2] - zy[1][2]) * a3;
			a = zab[1][1] - zx3b3 - zy3a3 + zxy[1][1];
			b = zx4b3 - zx3b3 - zxy[2][1] + zxy[1][1];
			c = zy4a3 - zy3a3 - zxy[1][2] + zxy[1][1];
			d = zxy[2][2] - zxy[2][1] - zxy[1][2] + zxy[1][1];
			e = a + a - b - c;
			a3sq = a3 * a3;
			b3sq = b3 * b3;
			p02 = (2.0 * (zb[0][2] - zy[1][1]) + zb[0][2] - zy[1][2]) * b3;
			p03 = (-2.0 * zb[0][2] + zy[1][2] + zy[1][1]) * b3sq;
			p12 = (2.0 * (zx3b3 - zxy[1][1]) + zx3b3 - zxy[1][2]) * b3;
			p13 = (-2.0 * zx3b3 + zxy[1][2] + zxy[1][1]) * b3sq;
			p20 = (2.0 * (za[2][0] - zx[1][1]) + za[2][0] - zx[2][1]) * a3;
			p21 = (2.0 * (zy3a3 - zxy[1][1]) + zy3a3 - zxy[2][1]) * a3;
			p22 = (3.0 * (a + e) + d) * a3 * b3;
			p23 = (-3.0 * e - b - d) * a3 * b3sq;
			p30 = (-2.0 * za[2][0] + zx[2][1] + zx[1][1]) * a3sq;
			p31 = (-2.0 * zy3a3 + zxy[2][1] + zxy[1][1]) * a3sq;
			p32 = (-3.0 * e - c - d) * b3 * a3sq;
			p33 = (d + e + e) * a3sq * b3sq;
		}
		dy = v[k] - y3;
		q0 = z33 + dy * (zy[1][1] + dy * (p02 + dy * p03));
		q1 = zx[1][1] + dy * (zxy[1][1] + dy * (p12 + dy * p13));
		q2 = p20 + dy * (p21 + dy * (p22 + dy * p23));
		q3 = p30 + dy * (p31 + dy * (p32 + dy * p33));
		dx = u[k] - x3;
		w[k] = q0 + dx * (q1 + dx * (q2 + dx * q3));

	}

}  // end itplbv function ---------------------------------------------------------------------


function tvfmfs_metric(erp, haat, channel, field, distance, fs_or_dist, curve, flag) {
	var id50 = 25;
	var ih50 = 13;
	var id10 = 31;
	var ih10 = 13;
	var range = 100.0;
	var delta = 0.5;
	var erp_db = 0.0;
	var d_first = 0.0;
	var d_last = 0.0;
	var e_volts_meter = 0.0;
	var n_points = 1001;


	//var erp_copy = erp;
	//var distance_copy = distance;
	//var field_copy = field;

	var i = 0;
	var j = 1;

	var d = [];
	var h = [];
	var f = [];
	var f5050 = [];
	var f5010 = [];

	//For F(50,90) curves 
	var L = 50.0;
	var T = 90.0;
	var ZQ = 0.0;
	var sigma = 0.0;
	var RL = 0.0;
	var RT = 0.0;

	//var flag = [];

	for (i = 0; i < 19; i++) {
		flag[i] = 0;
	}

	// Input data checks

	if ((channel < 2 || channel > 300) || (channel > 69 && channel < 200) || channel === '') { 
		flag[3] = 1; 
	}

	if (erp < 0.0001) {
		flag[6] = 1;
		if (erp < 0.0001 && erp > 0.00000001) { erp = 0.0001; }
	}

	if (((channel >= 2 && channel <= 6) || (channel >= 200 && channel <= 300)) && (erp > 400.5)) { 
		flag[12] = 1; 
	} else if ((channel >= 7 && channel <= 13) && (erp > 400.5)) { 
		flag[13] = 1; 
	} else if ((channel >= 14 && channel <= 69) && (erp > 5500.5)) { 
		flag[14] = 1; 
	}

	if ((curve === 0 || curve === 2) && distance > 300.0) { 
		flag[15] = 1; 
	} else if (curve === 1 && distance > 500.0) { 
		flag[16] = 1; 
	}

	if (curve < 0 || curve > 2 || curve === '') { 
		flag[4] = 1; 
	}
	
	if (fs_or_dist < 1 || fs_or_dist > 3 || fs_or_dist === '') { 
		flag[5] = 1; 
	}

	if (fs_or_dist === 1 && field < 0.0) { 
		flag[9] = 1; 
		field = Math.abs(field);
	}
	
	if (fs_or_dist === 2 && distance < 0.0) { 
		flag[9] = 1; 
		distance = Math.abs(distance); 
	}

	var field_for_erp;       	
	if (fs_or_dist === 3) { 	//find FM ERP, given a HAAT and a distance
		field_for_erp = 60.0;	// 60 dBu used to determine equivalence
		erp = 1.0;              // initial value
		if (channel < 200) {
			flag[17] = 1;  		// No TV calculations here
		}
		curve = 0;              // Service contour only
		//channel = 250;
	}

	erp_db = 10.0 * (Math.log(erp) / Math.log(10));
	// Math.log(x)/Math.log(10) = log10(x) which is not supported in some browsers

	if (haat < 30.0) { // All HAAT below 30 meters are set to 30
		haat = 30.0; 
		flag[7] = 1; 
	} else if (haat > 1600) { // All HAAT above 1600 are set to 1600
		haat = 1600.0; 
		flag[8] = 1; 
	}  

	if (flag[3] === 1 || flag[4] === 1 || flag[5] === 1) { 
		return flag; //need more info -- NO CALCULATIONS
	} else if (flag[12] === 1 || flag[13] === 1 || flag[14] === 1 || flag[15] === 1 || flag[16] === 1 || flag[17] === 1) { 
		return flag; //need more info -- NO CALCULATIONS
	} 

	/***********************************************************************
	!     FOR fs_or_dist = 1, FIND THE "FIELD" AT THE DISTANCE SPECIFIED IN    *
	!     "DISTANCE".  IF THE DISTANCE IS LESS THAN 1.5 KM, USE THE FREE   *
	!     SPACE EQUATION.                                                  *
	!**********************************************************************/



	if (fs_or_dist === 1 || fs_or_dist === 3) {
		n_points = 1;
		j = 1;
		if (distance < 1.5) {
			field = (106.92 - (20.0 * (Math.log(distance) / Math.log(10)))) + erp_db;
			// Math.log(x)/Math.log(10) = log10(x) which is not supported in some browsers (Internet Explorer)
			flag[1] = 1;

			return field;

		}
		if ((curve === 0 && distance > 300.0) || (curve === 1 && distance > 500.0)) {
			flag[2] = 1;
		} else {
			h[0] = haat;       // Only one point sought
			d[0] = distance;

			RL = 0.0;

			if ((channel >= 2 && channel <= 6) || (channel >= 200 && channel <= 300)) { // FM & analog TV channels 2-6
				if (curve === 0 || (curve === 1 && distance < 15.0)) {
					itplbv(id50, ih50, D50, H50, F55LV, j, d, h, f);
				} else if (curve === 1) {
					itplbv(id10, ih10, D10, H10, F51LV, j, d, h, f);
				} else if (curve === 2) {
					if (distance >= 15) {
						itplbv(id50, ih50, D50, H50, F55LV, j, d, h, f5050);
						itplbv(id10, ih10, D10, H10, F51LV, j, d, h, f5010);
					} else if (distance < 15) {
						itplbv(id50, ih50, D50, H50, F55LV, j, d, h, f5050);
						f5010[0] = f5050[0]; // use F5050 curves below 15 km
					}

					// F(50,90) means field strength at 50% of the locations, 90% of the time
					// Here we can alter the location variability parameter L.  This changes the field strength result.
					// But since in practice, we never use this, it is commented out.  
					// It is retained here for reference only.

					// if( L != 50. )
					// {
					//  ZQ = fzq(L); 
					//  sigma = 11.88; // > 470 MHz
					//  RL = ZQ * sigma;
					// } 
				}
			} else if (channel >= 7 && channel <= 13) {
				if (curve === 0 || (curve === 1 && distance < 15.0)) {
					itplbv(id50, ih50, D50, H50, F55HV, j, d, h, f);
				} else if (curve === 1) {
					itplbv(id10, ih10, D10, H10, F51HV, j, d, h, f);

				} else if (curve === 2) {
					if (distance >= 15) {
						itplbv(id50, ih50, D50, H50, F55HV, j, d, h, f5050);
						itplbv(id10, ih10, D10, H10, F51HV, j, d, h, f5010);
					} else if (distance < 15) {
						itplbv(id50, ih50, D50, H50, F55HV, j, d, h, f5050);
						f5010[0] = f5050[0]; // use F5050 curves below 15 km
					}

					// F(50,90) means field strength at 50% of the locations, 90% of the time
					// Here we can alter the location variability parameter L.  This changes the field strength result.
					// But since in practice, we never use this, it is commented out.  
					// It is retained here for reference only.

					// if( L != 50. )
					// {
					//  ZQ = fzq(L); 
					//  sigma = 11.88; // > 470 MHz
					//  RL = ZQ * sigma;
					// } 
				}

			} else if (channel >= 14 && channel <= 69) {
				if (curve === 0 || (curve === 1 && distance < 15.0)) { //F(50,50)
					itplbv(id50, ih50, D50, H50, F55U, j, d, h, f);
				} else if (curve === 1) { // F(50,10)
					itplbv(id10, ih10, D10, H10, F51U, j, d, h, f);
				} else if (curve === 2) { // F(50,90)
					if (distance >= 15) {
						itplbv(id50, ih50, D50, H50, F55U, j, d, h, f5050);
						itplbv(id10, ih10, D10, H10, F51U, j, d, h, f5010);
					} else if (distance < 15) {
						itplbv(id50, ih50, D50, H50, F55U, j, d, h, f5050);
						f5010[0] = f5050[0]; // use F5050 curves below 15 km
					}

					// F(50,90) means field strength at 50% of the locations, 90% of the time
					// Here we can alter the location variability parameter L.  This changes the field strength result.
					// But since in practice, we never use this, it is commented out.  
					// It is retained here for reference only.

					// if( L != 50. )
					// {
					//  ZQ = fzq(L); 
					//  sigma = 11.88; // > 470 MHz
					//  RL = ZQ * sigma;
					// } 
				}
			}
		}
		if (flag[1] === 1) {
			// no changes to field value
		}

		if (curve === 0 || curve === 1) {
			field = f[0] + erp_db;
		} else if (curve === 2) {
			ZQ = fzq(T);
			RT = (f5010[0] - f5050[0]) * (ZQ / 1.28155);
			field = f5050[0] + RL + RT + erp_db;
		}

		if (fs_or_dist === 3) { // then we find the FM ERP in kW and return that
			erp = Math.pow(10, ((field_for_erp - field) / 10.0));
			if (erp > 100) {
				flag[10] = 1;
			}
			return erp;
		} else {
			return field;
		}

	} // end fs_or_dist == 1

	/***********************************************************************
	!     FOR fs_or_dist = 2, THE "DISTANCE" FOR A SPECIFIED "FIELD" VALUE IS
	!     FOUND BY COMPUTING A FIELD VS. DISTANCE CURVE AT
	!     INCREMENTS OF 0.5 KILOMETER AND THEN FINDING THE CORRECT DISTANCE VALUE
	!     BY  INTERPOLATING BETWEEN THE FIELD POINTS.                          
	!***********************************************************************/

	else if (fs_or_dist === 2) {

		//console.log('erp=', erp)
		j = n_points;

		for (i = 0; i <= n_points; i++) { 
			h[i] = haat; 
			f5050[i] = f5010[i] = f[i] = d[i] = 0.0; 
		}

		if (curve === 0 || curve === 2) { 
			d_first = 1.5; 
			d_last = 300.0; 
		} else if (curve === 1) { 
			d_first = 15.0; 
			d_last = 500.0; 
		}
		
		var k = Math.floor(d_first / delta);
		for (i = k; i <= n_points; i++) { 
			d[i] = (i * delta); 
		}  // d_first/delta must be an integer

		//continue110:

		if ((channel >= 2 && channel <= 6) || (channel >= 200 && channel <= 300)) {
			if (curve === 0) {
				itplbv(id50, ih50, D50, H50, F55LV, j, d, h, f);
			} else if (curve === 1) {
				itplbv(id10, ih10, D10, H10, F51LV, j, d, h, f);
			} else if (curve === 2) {
				itplbv(id50, ih50, D50, H50, F55LV, j, d, h, f5050);
				itplbv(id10, ih10, D10, H10, F51LV, j, d, h, f5010);

				// F(50,90) means field strength at 50% of the locations, 90% of the time
				// Here we can alter the location variability parameter L.  This changes the field strength result.
				// But since in practice, we never use this, it is commented out.  
				// It is retained here for reference only.

				// if( L != 50. )
				// {
				//  ZQ = fzq(L); 
				//  sigma = 11.88; // > 470 MHz
				//  RL = ZQ * sigma;
			}

		} else if (channel >= 7 && channel <= 13) {
			if (curve === 0) {
				itplbv(id50, ih50, D50, H50, F55HV, j, d, h, f);
			} else if (curve === 1) {
				itplbv(id10, ih10, D10, H10, F51HV, j, d, h, f);
			} else if (curve === 2) {
				itplbv(id50, ih50, D50, H50, F55HV, j, d, h, f5050);
				itplbv(id10, ih10, D10, H10, F51HV, j, d, h, f5010);

				// F(50,90) means field strength at 50% of the locations, 90% of the time
				// Here we can alter the location variability parameter L.  This changes the field strength result.
				// But since in practice, we never use this, it is commented out.  
				// It is retained here for reference only.

				// if( L != 50. )
				// {
				//  ZQ = fzq(L); 
				//  sigma = 11.88; // > 470 MHz
				//  RL = ZQ * sigma;
			}

		} else if (channel >= 14 && channel <= 69) {
			if (curve === 0) {
				itplbv(id50, ih50, D50, H50, F55U, j, d, h, f);
			} else if (curve === 1) {
				itplbv(id10, ih10, D10, H10, F51U, j, d, h, f);
			} else if (curve === 2) {
				itplbv(id50, ih50, D50, H50, F55U, j, d, h, f5050);
				itplbv(id10, ih10, D10, H10, F51U, j, d, h, f5010);

				// F(50,90) means field strength at 50% of the locations, 90% of the time
				// Here we can alter the location variability parameter L.  This changes the field strength result.
				// But since in practice, we never use this, it is commented out.  
				// It is retained here for reference only.

				// if( L != 50. )
				// {
				//  ZQ = fzq(L); 
				//  sigma = 11.88; // > 470 MHz
				//  RL = ZQ * sigma;
			}
		}

		if (curve === 1 || curve === 2) {
			// add in the 3 to 15 km range to the f field strength array 
			// for F(50,10) interfering contours only.  Since the F(50,10) interfering 
			// contours start at 15 km, we use the F(50,50) curves in this range.					 
			var d1 = [];
			var f1 = [];  //alert(channel);

			for (i = 0; i < 30; i++) {
				f[i] = 0.0;
			}
			for (i = 0; i < n_points; i++) { 
				d1[i] = (i * delta); 
				f1[i] = 0.0; 
			}

			if ((channel >= 2 && channel <= 6) || (channel >= 200 && channel <= 300)) { 
				itplbv(id50, ih50, D50, H50, F55LV, j, d1, h, f1); 
			} else if (channel >= 7 && channel <= 13) { 
				itplbv(id50, ih50, D50, H50, F55HV, j, d1, h, f1); 
			} else if (channel >= 14 && channel <= 69) { 
				itplbv(id50, ih50, D50, H50, F55U, j, d1, h, f5050); 
			}

			//i=i for FM vhf uhf

			for (i = 0; i < 30; i++) {
				if (curve === 1) { 
					f[i] = f1[i] * 1.0; 
				} else if (curve === 2) { 
					f[i] = f5010[i] = f5050[i] * 1.0; 
				}

				d[i] = (i * delta);
			}

			//  for(i=0; i<35; i++) document.write(f[i] + '  ' + i + '  ' + f1[i] + '  ' + d[i] + '<br>');


		}

		//console.log('here, field=', field, 'f0=', f[0], 'f1=', f[1], 'f2=', f[2])

		for (i = 3; i > 0; i--) { // i = 2,1 0 (3 points) 1.5, 1, 0.5
			if (field > f[i]) { 	
				// High field strength, very close to transmitter site 
				// Service AND Interfering contours.
				// Use the free space equation to find the field strength and distance

				flag[1] = 1;
				e_volts_meter = 1.0e-6 * Math.pow(10, (field / 20.0));
				distance = (7.014271e-3 * Math.sqrt(erp * 1000.0)) / e_volts_meter;

				// Added 9/2004 to prevent free space distance from exceeding minimum curves distance of 
				// 1.5 km (to eliminate the discontinuity between the free space and curves values)

				// if(distance >= 1.5) { distance = 1.5; flag[1] = 0; }

				return distance;
			}
		}


		for (i = 0; i < n_points; i++) {
			// points i=0,1,2 covered by free space equation immediately above
			if (curve === 0 || curve === 1) {
				f[i] = f[i] + erp_db;
			} else if (curve === 2) {
				ZQ = fzq(T);  // T is the time variable in F(50,90) = the 90 
				RT = (f5010[i] - f5050[i]) * (ZQ / 1.28155);
				f[i] = f5050[i] + RL + RT + erp_db;
			}
		}

		// Most common, for service and interfering contours             

		for (i = 1; i < n_points; i++) { // start at 1
			if (field > f[i] && field < f[i - 1]) {
				// TEST alert(i + '  '  + field +'  ' + f[i-1] + '  ' + f[i] + '  ' + d[i] + '  ' + d[i-1]);   

				distance = (((f[i - 1] - field) / (f[i - 1] - f[i])) * (d[i] - d[i - 1])) + d[i - 1];

				//console.log('i', i, 'dist', distance)
				if (distance > d_last) {
					flag[2] = 1;
				}

				return distance;
			}
		}

		// should not get here!

	} // end distance
} // end tvfmfs_metric ----------------------------------------------------------------------------------

function tvfmfs_comment(i) {
	var comment;
	if (i === 0) {
		comment = '';
	} else if (i === 1) {
		comment = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Free Space equation used to compute distance.<br>\n';
	} else if (i === 2) {
		comment = '<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entered distance exceeds maximum curve distance.<br>\n';
	} else if (i === 3) {
		comment = '<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select a channel range.<br>\n';
	} else if (i === 4) {
		comment = '<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select a contour type.<br>\n';
	} else if (i === 5) {
		comment = '<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select the desired result (Find This).<br>\n';
	} else if (i === 6) {
		comment = '<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERP of less than 0.0001 kW (0.1 watt) is changed to 0.0001 kW for calculations.<br>\n';
	} else if (i === 7) {
		comment = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entered HAAT is less than 30 meters; changed to 30 meters for calculations.<br>\n';
	} else if (i === 8) {
		comment = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entered HAAT is greater than 1600 meters; changed to 1600 meters for calculations.<br>\n';
	} else if (i === 9) {
		comment = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entered Field or Distance is less than zero; set to positive for calculations.<br>\n';
	} else if (i === 10) {
		comment = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERP exceeds the maximum of 100 kW permitted for U.S. FM stations.<br>\n';
	} else if (i === 11) {
		comment = '<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Non-numeric data entered in a form input.<br>\n';
	} else if (i === 12) {
		comment = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum ERP for VHF, TV Channels 2-6, is 400 kW. <br>\n';
	} else if (i === 13) {
		comment = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum ERP for VHF, TV Channels 7-13, is 400 kW. <br>\n';
	} else if (i === 14) {
		comment = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum ERP for UHF, TV Channels 14-69, is 5500 kW. <br>\n';
	} else if (i === 15) {
		comment = '<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum curve <b>distance</b> for service contours is limited to 300 km. <br>\n';
	} else if (i === 16) {
		comment = '<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum curve <b>distance</b> for interfering contours is limited to 500 km.<br>\n';
	} else if (i === 17) {
		comment = '<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The \'Find ERP\' calculation is not valid for the TV service.<br>\n';
	} else if (i === 18) {
		comment = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum ERP for VHF, FM Channel 6, is 400 kW. <br>\n';
	} else if (i === 19) {
		comment = 'Feature not yet implemented.';
	} else {
		comment = '';
	}
	return comment;
}


function fzq(Q) // for F(50,90) curves prediction
{
	var k;
	var ZGRID = [];

	var ZQ = 0.0; // Initialize

	for (k = 0; k <= 57; k++) {
		ZGRID[k] = -ZGRI[k];
		ZGRID[114 - k] = ZGRI[k];
	}

	for (k = 1; k < 115; k++) {
		if (VGRID[k] < Q) {

		} else {
			ZQ = ZGRID[k - 1] + ((Q - VGRID[k - 1]) / (VGRID[k] - VGRID[k - 1])) * (ZGRID[k] - ZGRID[k - 1]);
			if (ZQ !== ZQ) {
				ZQ = 0.0;  // Checking for NaN, set to 0 (means no curve shifts for Q)
			}
			return ZQ;
		}
	}

}   // end fzq  

function round_power(power_in, error_flag) {

	/************************************************************************
	*
	*     This subroutine will round the power in accordance with the FCC
	*     Rules section 73.212.
	*
	*     POWER_IN   = Unrounded power in Watts or kilowatts; real; input.
	*     POWER_OUT  = Rounded power in Watts or kilowatts; real; output.
	*     ERROR_FLAG = 0; no errors; integer; output.
	*                = 1; Input power is less than minimum allowed,
	*                     POWER_OUT set equal to POWER_IN.
	*                = 2; Input power greater than maximum allowed,
	*                     POWER_OUT set equal to POWER_IN.
	*
	*                     ...kalagian...11/3/86...
	*
	***********************************************************************/

	var power_out = 0.0;
	var round_factor = 0.0;

	var error_flag = 0;
	power_out = power_in + 0.000000000001;  // to insure a nonzero power_in

	if (power_in >= 0.001 && power_in < 0.003) { 
		round_factor = 0.00005;
	} else if (power_in >= 0.003 && power_in < 0.01) { 
		round_factor = 0.0001; 
	} else if (power_in >= 0.01 && power_in < 0.03) { 
		round_factor = 0.0005; 
	} else if (power_in >= 0.03 && power_in < 0.1) { 
		round_factor = 0.001; 
	} else if (power_in >= 0.10 && power_in < 0.3) { 
		round_factor = 0.005; 
	} else if (power_in >= 0.30 && power_in < 1.0) { 
		round_factor = 0.01;
	} else if (power_in >= 1.0 && power_in < 3.0) { 
		round_factor = 0.05; 
	} else if (power_in >= 3.00 && power_in < 10.0) { 
		round_factor = 0.1; 
	} else if (power_in >= 10.0 && power_in < 30.0) { 
		round_factor = 0.5; 
	} else if (power_in >= 30.0 && power_in < 100.0) { 
		round_factor = 1.0; 
	} else if (power_in >= 100.0 && power_in < 300.0) { 
		round_factor = 5.0; 
	} else if (power_in >= 300.0 && power_in < 1000.0) { 
		round_factor = 10.0; 
	}

	power_out = power_in / round_factor;
	power_out = Math.floor(Math.round(power_out));
	power_out = power_out * round_factor;

	if (power_in > 1000.0) { 
		power_out = Math.floor(power_in);
	}

	return (power_out);
}

function getResult(req, res, callback) {
	console.log('================ Start CURVES API ===================');
	/*
	 * Refactored 6/20/18 by Sam Bressi
	 * Instead of calling getDistance directly, the input validations
	 *  are wrapped in a getResults wrapper, which adds in the computationMethod.
	 * 
	 * The computationMethod is 0, 1, or 2 depending on if the user wants
	 *  to calculate the distance, field strength, or maximum ERP.
	 * 
	 * Using computationMethod 0 calls getDistance and the API should work as
	 *  originally built. New functionality added in to call getFieldStrength
	 *  and getMaxPower when computation method is 1 or 2 respectively.
	 */

	var dataObj = {};
	dataObj.status = 'error';
	dataObj.statusCode = 400;
	dataObj.statusMessage = '';

	try {
		var haat = req.query.haat;
		var field = req.query.field;
		var erp = req.query.erp;
		var distance = req.query.distance;
		var channel = req.query.channel;
		var curve = req.query.curve;
		var serviceType = req.query.serviceType;
		var computationMethod = req.query.computationMethod;

		// *** REQUIRED FIELD CHECKS *** //
		// *** SERVICE TYPE CHECKS *** //
		if (serviceType === undefined) {
			console.log('Missing serviceType');
			dataObj.statusMessage = 'Missing serviceType parameter.';
			return callback(dataObj);
		}

		serviceType = serviceType.toLowerCase();

		// *** COMPUTATION METHOD CHECKS *** //
		// Valid values:
		// 0: distance (default)
		// 1: field strength
		// 2: max ERP
		if (computationMethod === undefined) {
			computationMethod = '0';
			console.log('Computation method not provided. Forcing 0 (distance) for backward compatibility.');
		}

		if (!computationMethod.match(/^\d+$/)) {
			console.log('invalid computationMethod value');
			dataObj.statusMessage = 'Invalid computationMethod value.';
			return callback(dataObj);
		}

		computationMethod = parseFloat(computationMethod);

		if (computationMethod < 0 || computationMethod > 2) {
			console.log('Computation method value out of range [0, 2]');
			dataObj.statusMessage = 'Computation method value out of range [0, 2].';
			return callback(dataObj);
		}

		var tv_fm_list = ['tv', 'fm'];
		if (tv_fm_list.indexOf(serviceType) < 0) {
			console.log('invalid serviceType value');
			dataObj.statusMessage = 'Invalid serviceType value.';
			return callback(dataObj);
		}

		// *** HAAT CHECKS *** //
		if (haat === undefined) {
			console.log('Missing haat');
			dataObj.statusMessage = 'Missing haat.';
			return callback(dataObj);
		}

		// ** Ahmad Aburizaiza **
		// the regexp fixed to include negative numbers
		if (!haat.match(/^-?\d+\.?\d*$/)) {
			console.log('invalid haat value');
			dataObj.statusMessage = 'Invalid haat value.';
			return callback(dataObj);
		}

		if (parseFloat(haat) > 1600.0) {
			console.log('HAAT value out of range ( > 1600)');
			dataObj.statusMessage = 'HAAT value cannot exceed 1600.';
			return callback(dataObj);
		}

		// *** CHANNEL CHECKS *** //
		if (channel === undefined) {
			if (serviceType === 'tv') {
				console.log('Missing channel');
				dataObj.statusMessage = 'Missing channel.';
				return callback(dataObj);
			} else if ((serviceType === 'fm') && ((computationMethod === 0) || (computationMethod === 1))) {
				channel = '6';
			} else {
				channel = '250';
			}
		}

		if (channel && !channel.match(/\d+$/)) {
			console.log('invalid channel value');
			dataObj.statusMessage = 'Invalid channel value.';
			return callback(dataObj);
		}

		/*
		if(serviceType === 'fm' && (channel !== '6' || channel == undefined)){
			console.log('Channel 6 is the only valid channel for FM services');
			dataObj.statusMessage = 'Only channel 6 allowed for FM services';
			return callback(dataObj);
		}
		*/

		// *** CURVE CHECKS *** //
		// Valid values:
		// 0: F(50,50)
		// 1: F(50,10)
		// 2: F(50,90)
		if (curve === undefined) {
			console.log('Missing curve');
			dataObj.statusMessage = 'Missing curve.';
			return callback(dataObj);
		}

		if (!curve.match(/^\d+$/)) {
			console.log('invalid curve value');
			dataObj.statusMessage = 'Invalid curve value.';
			return callback(dataObj);
		}

		if (parseFloat(curve) < 0 || parseFloat(curve) > 2) {
			console.log('Curve value out of range [0, 2]');
			dataObj.statusMessage = 'Curve value out of range [0, 2].';
			return callback(dataObj);
		}

		haat = parseFloat(haat);
		channel = parseFloat(channel);
		curve = parseFloat(curve);

		// ** Ahmad Aburizaiza **
		// update the value of haat to 30 if it is less than 30
		// the value is updated in tvfmfs_metric(..) but not returned
		// for the post code that requires the updated haat value
		if (parseFloat(haat) < 30.0) {
			haat = 30.0;
		}

		// *** END REQUIRED FIELD CHECKS *** //

		// Determine which optional fields are needed based on the computation method
		// CM 0 (Distance) - Requires field strength and ERP
		// CM 1 (Field Strength) - Requires distance and ERP
		// CM 2 (ERP) - Requires distance and field strength
		var result = -1;

		if (computationMethod === 0) {
			if (field === undefined) {
				console.log('Mssing field strength.');
				dataObj.statusMessage = 'Missing field';
				return callback(dataObj);
			}

			if (erp === undefined) {
				console.log('Mssing erp.');
				dataObj.statusMessage = 'Missing erp';
				return callback(dataObj);
			}

			if (!field.match(/^-?\d+\.?\d*$/)) {
				console.log('Invalid field strength value.');
				dataObj.statusMessage = 'Invalid field value';
				return callback(dataObj);
			}

			if (!erp.match(/^\d+\.?\d*$/)) {
				console.log('Invalid erp value.');
				dataObj.statusMessage = 'Invalid erp value';
				return callback(dataObj);
			}

			field = parseFloat(field);
			erp = parseFloat(erp);

			result = getDistance(haat, serviceType, channel, curve, field, erp);
		} else if (computationMethod === 1) {
			if (distance === undefined) {
				console.log('Mssing distance.');
				dataObj.statusMessage = 'Missing distance';
				return callback(dataObj);
			}

			if (erp === undefined) {
				console.log('Mssing erp.');
				dataObj.statusMessage = 'Missing erp';
				return callback(dataObj);
			}

			if (!distance.match(/^-?\d+\.?\d*$/)) {
				console.log('Invalid distance value.');
				dataObj.statusMessage = 'Invalid distance value';
				return callback(dataObj);
			}

			if (!erp.match(/^\d+\.?\d*$/)) {
				console.log('Invalid erp value.');
				dataObj.statusMessage = 'Invalid erp value';
				return callback(dataObj);
			}

			distance = parseFloat(distance);
			erp = parseFloat(erp);

			result = getFieldStrength(haat, serviceType, channel, curve, erp, distance);
		} else if (computationMethod === 2) {
			if (distance === undefined) {
				console.log('Mssing distance.');
				dataObj.statusMessage = 'Missing distance';
				return callback(dataObj);
			}

			if (field === undefined) {
				console.log('Mssing field strength.');
				dataObj.statusMessage = 'Missing field';
				return callback(dataObj);
			}

			if (!distance.match(/^-?\d+\.?\d*$/)) {
				console.log('Invalid distance value.');
				dataObj.statusMessage = 'Invalid distance value';
				return callback(dataObj);
			}

			if (!field.match(/^-?\d+\.?\d*$/)) {
				console.log('Invalid field strength value.');
				dataObj.statusMessage = 'Invalid field value';
				return callback(dataObj);
			}

			distance = parseFloat(distance);
			field = parseFloat(field);
			result = getMaxPower(haat, serviceType, channel, curve, field, distance);
		}

		console.log('computationMethod=' + computationMethod);
		console.log('result=');
		console.log(result);

		if (isNaN(result)) {
			var comments = '';
			for (var i = 0; i < result.length; i++) {
				if (result[i] === 1) {
					var comment;
					if (i === 12 && serviceType.toLowerCase() === 'fm') {
						console.log('comment for item=18');
						comment = tvfmfs_comment(18).replace(/^.*;/, '').replace(/\..*\n/, '');
						comments += comment + ';';
					} else {
						console.log('comment for item=' + i);
						comment = tvfmfs_comment(i).replace(/^.*;/, '').replace(/\..*\n/, '');
						comments += comment + ';';
					}
				}
			}

			comments = comments.replace(/;$/, '');
			dataObj.statusMessage = comments;
			return callback(dataObj);
			//		} else if (result < 0) {
			//			dataObj.statusMessage = 'CURVES error occurred when calculating computation method'
			//			return callback(dataObj);

		} else {
			dataObj.status = 'success';
			dataObj.statusCode = '200';
			dataObj.statusMessage = 'ok';
			dataObj.haat = haat;
			dataObj.haat_unit = 'm';
			dataObj.channel = channel;
			dataObj.curve = curve;
			dataObj.serviceType = serviceType;
			dataObj.computationMethod = computationMethod;
			if (computationMethod === 0) {
				dataObj.computedField = 'distance';
				dataObj.distance = mathjs.round(result, 3);
				dataObj.field = mathjs.round(field, 1);
				dataObj.erp = mathjs.round(erp, 3);
			} else if (computationMethod === 1) {
				dataObj.computedField = 'field';
				dataObj.distance = mathjs.round(distance, 3);
				dataObj.field = mathjs.round(result, 3);
				dataObj.erp = mathjs.round(erp, 3);
			} else if (computationMethod === 2) {
				dataObj.computedField = 'erp';
				dataObj.distance = mathjs.round(distance, 3);
				dataObj.field = mathjs.round(field, 1);
				dataObj.erp = mathjs.round(result, 3);
			}
			dataObj.distance_unit = 'km';
			dataObj.field_unit = 'dbu';
			dataObj.erp_unit = 'kw';

			return callback(dataObj);
		}


	}
	catch (err) {
		console.log('err=' + err);
		dataObj.error = err.stack;
		dataObj.statusMessage = 'CURVES error occurred.';
		return callback(dataObj);
	}
}

function getFieldStrength(haat, serviceType, channel, curve, erp, distance) {
	console.log('================ Start CURVES Field Strength API ===================');
	var fs_or_dist = 1;
	var flag = [];
	var field = tvfmfs_metric(erp, haat, channel, field, distance, fs_or_dist, curve, flag);
	return field;
}

function getMaxPower(haat, serviceType, channel, curve, field, distance) {
	console.log('================ Start CURVES Max ERP API ===================');
	var fs_or_dist = 1;
	var flag = [];
	var erp = 1;
	var field2 = getFieldStrength(haat, serviceType, channel, curve, erp, distance);
	var power_in = Math.pow(10, (field - field2) / 10);
	var power_out = round_power(power_in);
	return power_out;
}

function getDistance(haat, serviceType, channel, curve, field, erp) {
	console.log('================ Start CURVES Distance API ===================');
	var fs_or_dist = 2;
	var flag = [];
	var distance = tvfmfs_metric(erp, haat, channel, field, distance, fs_or_dist, curve, flag);
	return distance;
}

module.exports.tvfmfs_metric = tvfmfs_metric;
module.exports.getResult = getResult;



